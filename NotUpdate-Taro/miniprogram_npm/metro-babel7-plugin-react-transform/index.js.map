{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * In order to speed things up, we use transform caching. However, the project\n * codebase moves very fast and cache becomes invalid when some files change.\n *\n * CacheKey is used to generate a unique string that can be used as cache key.\n * The cache key consists of various dependency cache keys that change if the\n * output of the transform would change.\n *\n * Imported from https://github.com/gaearon/babel-plugin-react-transform\n * https://github.com/gaearon/babel-plugin-react-transform/commit/d7069df5c6f36a07857fd108067dc515b3a795ee\n *\n * @format\n * @noflow\n */\n // temporary workaround, don't mind this package\n\n/*eslint-disable eslint-comments/no-unlimited-disable*/\n\n/*eslint-disable*/\n\nconst _require = require(\"@babel/helper-module-imports\"),\n  addDefault = _require.addDefault;\n\nconst _require2 = require(\"path\"),\n  relative = _require2.relative;\n\nfunction find(obj, func) {\n  let value = undefined;\n\n  if (!(obj instanceof Array)) {\n    obj = Object.values(obj);\n  }\n\n  obj.some((v, i) => {\n    if (func(v)) {\n      value = v;\n      return true;\n    }\n\n    return false;\n  });\n  return value;\n}\n\nmodule.exports = function(_ref) {\n  let t = _ref.types,\n    template = _ref.template;\n\n  function matchesPatterns(path, patterns) {\n    return !!find(patterns, pattern => {\n      return (\n        t.isIdentifier(path.node, {\n          name: pattern\n        }) || path.matchesPattern(pattern)\n      );\n    });\n  }\n\n  function isReactLikeClass(node) {\n    return !!find(node.body.body, classMember => {\n      return (\n        t.isClassMethod(classMember) &&\n        t.isIdentifier(classMember.key, {\n          name: \"render\"\n        })\n      );\n    });\n  }\n\n  function isReactLikeComponentObject(node) {\n    return (\n      t.isObjectExpression(node) &&\n      !!find(node.properties, objectMember => {\n        return (\n          (t.isObjectProperty(objectMember) ||\n            t.isObjectMethod(objectMember)) &&\n          (t.isIdentifier(objectMember.key, {\n            name: \"render\"\n          }) ||\n            t.isStringLiteral(objectMember.key, {\n              value: \"render\"\n            }))\n        );\n      })\n    );\n  } // `foo({ displayName: 'NAME' });` => 'NAME'\n\n  function getDisplayName(node) {\n    const property = find(\n      node.arguments[0].properties,\n      _node => _node.key.name === \"displayName\"\n    );\n    return property && property.value.value;\n  }\n\n  function hasParentFunction(path) {\n    return !!path.findParent(parentPath => parentPath.isFunction());\n  } // wrapperFunction(\"componentId\")(node)\n\n  function wrapComponent(node, componentId, wrapperFunctionId) {\n    return t.callExpression(\n      t.callExpression(wrapperFunctionId, [t.stringLiteral(componentId)]),\n      [node]\n    );\n  } // `{ name: foo }` => Node { type: \"ObjectExpression\", properties: [...] }\n\n  function toObjectExpression(object) {\n    const properties = Object.keys(object).map(key => {\n      return t.objectProperty(t.identifier(key), object[key]);\n    });\n    return t.objectExpression(properties);\n  }\n\n  const wrapperFunctionTemplate = template(`\n    function WRAPPER_FUNCTION_ID(ID_PARAM) {\n      return function(COMPONENT_PARAM) {\n        return EXPRESSION;\n      };\n    }\n  `);\n  const VISITED_KEY = \"react-transform-\" + Date.now();\n  const componentVisitor = {\n    Class(path) {\n      if (\n        path.node[VISITED_KEY] ||\n        !matchesPatterns(path.get(\"superClass\"), this.superClasses) ||\n        !isReactLikeClass(path.node)\n      ) {\n        return;\n      }\n\n      path.node[VISITED_KEY] = true;\n      const componentName = (path.node.id && path.node.id.name) || null;\n      const componentId = componentName || path.scope.generateUid(\"component\");\n      const isInFunction = hasParentFunction(path);\n      this.components.push({\n        id: componentId,\n        name: componentName,\n        isInFunction: isInFunction\n      }); // Can't wrap ClassDeclarations\n\n      const isStatement = t.isStatement(path.node);\n      const isExport = t.isExportDefaultDeclaration(path.parent);\n\n      if (isStatement && !isExport) {\n        // class decl\n        // need to work around Babel 7 detecting duplicate decls here\n        path.insertAfter(\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.identifier(componentId),\n              wrapComponent(\n                t.identifier(componentId),\n                componentId,\n                this.wrapperFunctionId\n              )\n            )\n          )\n        );\n        return;\n      }\n\n      const expression = t.toExpression(path.node); // wrapperFunction(\"componentId\")(node)\n\n      let wrapped = wrapComponent(\n        expression,\n        componentId,\n        this.wrapperFunctionId\n      );\n      let constId;\n\n      if (isStatement) {\n        // wrapperFunction(\"componentId\")(class Foo ...) => const Foo = wrapperFunction(\"componentId\")(class Foo ...)\n        constId = t.identifier(componentName || componentId);\n        wrapped = t.variableDeclaration(\"const\", [\n          t.variableDeclarator(constId, wrapped)\n        ]);\n      }\n\n      if (isExport) {\n        path.parentPath.insertBefore(wrapped);\n        path.parent.declaration = constId;\n      } else {\n        path.replaceWith(wrapped);\n      }\n    },\n\n    CallExpression(path) {\n      if (\n        path.node[VISITED_KEY] ||\n        !matchesPatterns(path.get(\"callee\"), this.factoryMethods) ||\n        !isReactLikeComponentObject(path.node.arguments[0])\n      ) {\n        return;\n      }\n\n      path.node[VISITED_KEY] = true; // `foo({ displayName: 'NAME' });` => 'NAME'\n\n      const componentName = getDisplayName(path.node);\n      const componentId = componentName || path.scope.generateUid(\"component\");\n      const isInFunction = hasParentFunction(path);\n      this.components.push({\n        id: componentId,\n        name: componentName,\n        isInFunction: isInFunction\n      });\n      path.replaceWith(\n        wrapComponent(path.node, componentId, this.wrapperFunctionId)\n      );\n    }\n  };\n\n  class ReactTransformBuilder {\n    constructor(file, options) {\n      this.file = file;\n      this.program = file.path;\n      this.options = this.normalizeOptions(options); // @todo: clean this shit up\n\n      this.configuredTransformsIds = [];\n    }\n\n    static validateOptions(options) {\n      return typeof options === \"object\" && Array.isArray(options.transforms);\n    }\n\n    static assertValidOptions(options) {\n      if (!ReactTransformBuilder.validateOptions(options)) {\n        throw new Error(\n          \"babel-plugin-react-transform requires that you specify options \" +\n            \"in .babelrc or from the Babel Node API, and that it is an object \" +\n            \"with a transforms property which is an array.\"\n        );\n      }\n    }\n\n    normalizeOptions(options) {\n      return {\n        factoryMethods: options.factoryMethods || [\"React.createClass\"],\n        superClasses: options.superClasses || [\n          \"React.Component\",\n          \"React.PureComponent\",\n          \"Component\",\n          \"PureComponent\"\n        ],\n        transforms: options.transforms.map(opts => {\n          return {\n            transform: opts.transform,\n            locals: opts.locals || [],\n            imports: opts.imports || []\n          };\n        })\n      };\n    }\n\n    build(path) {\n      const componentsDeclarationId = this.file.scope.generateUidIdentifier(\n        \"components\"\n      );\n      const wrapperFunctionId = this.file.scope.generateUidIdentifier(\n        \"wrapComponent\"\n      );\n      const components = this.collectAndWrapComponents(wrapperFunctionId);\n\n      if (!components.length) {\n        return;\n      }\n\n      const componentsDeclaration = this.initComponentsDeclaration(\n        componentsDeclarationId,\n        components\n      );\n      const configuredTransforms = this.initTransformers(\n        path,\n        componentsDeclarationId\n      );\n      const wrapperFunction = this.initWrapperFunction(wrapperFunctionId);\n      const body = this.program.node.body;\n      body.unshift(wrapperFunction);\n      configuredTransforms.reverse().forEach(node => body.unshift(node));\n      body.unshift(componentsDeclaration);\n    }\n    /**\n     * const Foo = _wrapComponent('Foo')(class Foo extends React.Component {});\n     * ...\n     * const Bar = _wrapComponent('Bar')(React.createClass({\n     *   displayName: 'Bar'\n     * }));\n     */\n\n    collectAndWrapComponents(wrapperFunctionId) {\n      const components = [];\n      this.file.path.traverse(componentVisitor, {\n        wrapperFunctionId: wrapperFunctionId,\n        components: components,\n        factoryMethods: this.options.factoryMethods,\n        superClasses: this.options.superClasses,\n        currentlyInFunction: false\n      });\n      return components;\n    }\n    /**\n     * const _components = {\n     *   Foo: {\n     *     displayName: \"Foo\"\n     *   }\n     * };\n     */\n\n    initComponentsDeclaration(componentsDeclarationId, components) {\n      const props = components.map(component => {\n        const componentId = component.id;\n        const componentProps = [];\n\n        if (component.name) {\n          componentProps.push(\n            t.objectProperty(\n              t.identifier(\"displayName\"),\n              t.stringLiteral(component.name)\n            )\n          );\n        }\n\n        if (component.isInFunction) {\n          componentProps.push(\n            t.objectProperty(\n              t.identifier(\"isInFunction\"),\n              t.booleanLiteral(true)\n            )\n          );\n        }\n\n        let objectKey;\n\n        if (t.isValidIdentifier(componentId)) {\n          objectKey = t.identifier(componentId);\n        } else {\n          objectKey = t.stringLiteral(componentId);\n        }\n\n        return t.objectProperty(objectKey, t.objectExpression(componentProps));\n      });\n      return t.variableDeclaration(\"const\", [\n        t.variableDeclarator(componentsDeclarationId, t.objectExpression(props))\n      ]);\n    }\n    /**\n     * import _transformLib from \"transform-lib\";\n     * ...\n     * const _transformLib2 = _transformLib({\n     *   filename: \"filename\",\n     *   components: _components,\n     *   locals: [],\n     *   imports: []\n     * });\n     */\n\n    initTransformers(path, componentsDeclarationId) {\n      return this.options.transforms.map(transform => {\n        const transformName = transform.transform;\n        const transformImportId = addDefault(path, transformName, {\n          nameHint: transformName\n        });\n        const transformLocals = transform.locals.map(local => {\n          return t.identifier(local);\n        });\n        const transformImports = transform.imports.map(importName => {\n          return addDefault(path, importName, {\n            hint: importName\n          });\n        });\n        const configuredTransformId = this.file.scope.generateUidIdentifier(\n          transformName\n        );\n        const configuredTransform = t.variableDeclaration(\"const\", [\n          t.variableDeclarator(\n            configuredTransformId,\n            t.callExpression(transformImportId, [\n              toObjectExpression({\n                filename: t.stringLiteral(\n                  // Equivalent to `this.file.opts.sourceFileName` when defined.\n                  this.file.opts.filename\n                    ? relative(this.file.opts.cwd, this.file.opts.filename)\n                    : \"unknown\"\n                ),\n                components: componentsDeclarationId,\n                locals: t.arrayExpression(transformLocals),\n                imports: t.arrayExpression(transformImports)\n              })\n            ])\n          )\n        ]);\n        this.configuredTransformsIds.push(configuredTransformId);\n        return configuredTransform;\n      });\n    }\n    /**\n     * function _wrapComponent(id) {\n     *   return function (Component) {\n     *     return _transformLib2(Component, id);\n     *   };\n     * }\n     */\n\n    initWrapperFunction(wrapperFunctionId) {\n      const idParam = t.identifier(\"id\");\n      const componentParam = t.identifier(\"Component\");\n      const expression = this.configuredTransformsIds\n        .reverse()\n        .reduce((memo, transformId) => {\n          return t.callExpression(transformId, [memo, idParam]);\n        }, componentParam);\n      return wrapperFunctionTemplate({\n        WRAPPER_FUNCTION_ID: wrapperFunctionId,\n        ID_PARAM: idParam,\n        COMPONENT_PARAM: componentParam,\n        EXPRESSION: expression\n      });\n    }\n  }\n\n  return {\n    visitor: {\n      Program(path, _ref2) {\n        let file = _ref2.file,\n          opts = _ref2.opts;\n        ReactTransformBuilder.assertValidOptions(opts);\n        const builder = new ReactTransformBuilder(file, opts);\n        builder.build(path);\n      }\n    }\n  };\n};\n"]}