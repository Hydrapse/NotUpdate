{"version":3,"sources":["index.js","normalizeOptions.js","utils.js","resolvePath.js","log.js","mapToRelative.js","transformers/call.js","transformers/import.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,AHSA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,ADGA;AFOA,AIZA,ACHA,AJYA,AENA,AGTA,AJYA;AFOA,AIZA,ACHA,AJYA,AENA,AGTA,AJYA;AFOA,AIZA,ACHA,AJYA,AENA,AGTA,AJYA;AFOA,AIZA,ACHA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AIZA,ACHA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,ACHA,ALeA;AFOA,AKfA,AJYA,AENA,AGTA,AJYA;AFOA,AKfA,AJYA,AENA,AGTA,AJYA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA;AFOA,AENA;AFOA,AENA;AFOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _normalizeOptions = _interopRequireDefault(require(\"./normalizeOptions\"));\n\nvar _resolvePath = _interopRequireDefault(require(\"./resolvePath\"));\n\nexports.resolvePath = _resolvePath.default;\n\nvar _call = _interopRequireDefault(require(\"./transformers/call\"));\n\nvar _import = _interopRequireDefault(require(\"./transformers/import\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Public API for external plugins\nconst importVisitors = {\n  CallExpression: _call.default,\n  'ImportDeclaration|ExportDeclaration': _import.default\n};\nconst visitor = {\n  Program: {\n    enter(programPath, state) {\n      programPath.traverse(importVisitors, state);\n    },\n\n    exit(programPath, state) {\n      programPath.traverse(importVisitors, state);\n    }\n\n  }\n};\n\nvar _default = ({\n  types\n}) => ({\n  name: 'module-resolver',\n\n  manipulateOptions(opts) {\n    if (opts.filename === undefined) {\n      opts.filename = 'unknown';\n    }\n  },\n\n  pre(file) {\n    this.types = types;\n    const currentFile = file.opts.filename;\n    this.normalizedOpts = (0, _normalizeOptions.default)(currentFile, this.opts); // We need to keep track of all handled nodes so we do not try to transform them twice,\n    // because we run before (enter) and after (exit) all nodes are handled\n\n    this.moduleResolverVisited = new Set();\n  },\n\n  visitor,\n\n  post() {\n    this.moduleResolverVisited.clear();\n  }\n\n});\n\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _reselect = require(\"reselect\");\n\nvar _findBabelConfig = _interopRequireDefault(require(\"find-babel-config\"));\n\nvar _glob = _interopRequireDefault(require(\"glob\"));\n\nvar _pkgUp = _interopRequireDefault(require(\"pkg-up\"));\n\nvar _utils = require(\"./utils\");\n\nvar _resolvePath = _interopRequireDefault(require(\"./resolvePath\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst defaultExtensions = ['.js', '.jsx', '.es', '.es6', '.mjs'];\nconst defaultTransformedFunctions = ['require', 'require.resolve', 'System.import', // Jest methods\n'jest.genMockFromModule', 'jest.mock', 'jest.unmock', 'jest.doMock', 'jest.dontMock', 'jest.setMock', 'require.requireActual', 'require.requireMock'];\n\nfunction isRegExp(string) {\n  return string.startsWith('^') || string.endsWith('$');\n}\n\nconst specialCwd = {\n  babelrc: startPath => _findBabelConfig.default.sync(startPath).file,\n  packagejson: startPath => _pkgUp.default.sync(startPath)\n};\n\nfunction normalizeCwd(optsCwd, currentFile) {\n  let cwd;\n\n  if (optsCwd in specialCwd) {\n    const startPath = currentFile === 'unknown' ? './' : currentFile;\n    const computedCwd = specialCwd[optsCwd](startPath);\n    cwd = computedCwd ? _path.default.dirname(computedCwd) : null;\n  } else {\n    cwd = optsCwd;\n  }\n\n  return cwd || process.cwd();\n}\n\nfunction normalizeRoot(optsRoot, cwd) {\n  if (!optsRoot) {\n    return [];\n  }\n\n  const rootArray = Array.isArray(optsRoot) ? optsRoot : [optsRoot];\n  return rootArray.map(dirPath => _path.default.resolve(cwd, dirPath)).reduce((resolvedDirs, absDirPath) => {\n    if (_glob.default.hasMagic(absDirPath)) {\n      const roots = _glob.default.sync(absDirPath).filter(resolvedPath => _fs.default.lstatSync(resolvedPath).isDirectory());\n\n      return [...resolvedDirs, ...roots];\n    }\n\n    return [...resolvedDirs, absDirPath];\n  }, []);\n}\n\nfunction getAliasTarget(key, isKeyRegExp) {\n  const regExpPattern = isKeyRegExp ? key : `^${(0, _utils.escapeRegExp)(key)}(/.*|)$`;\n  return new RegExp(regExpPattern);\n}\n\nfunction getAliasSubstitute(value, isKeyRegExp) {\n  if (typeof value === 'function') {\n    return value;\n  }\n\n  if (!isKeyRegExp) {\n    return ([, match]) => `${value}${match}`;\n  }\n\n  const parts = value.split('\\\\\\\\');\n  return execResult => parts.map(part => part.replace(/\\\\\\d+/g, number => execResult[number.slice(1)] || '')).join('\\\\');\n}\n\nfunction normalizeAlias(optsAlias) {\n  if (!optsAlias) {\n    return [];\n  }\n\n  const aliasArray = Array.isArray(optsAlias) ? optsAlias : [optsAlias];\n  return aliasArray.reduce((aliasPairs, alias) => {\n    const aliasKeys = Object.keys(alias);\n    aliasKeys.forEach(key => {\n      const isKeyRegExp = isRegExp(key);\n      aliasPairs.push([getAliasTarget(key, isKeyRegExp), getAliasSubstitute(alias[key], isKeyRegExp)]);\n    });\n    return aliasPairs;\n  }, []);\n}\n\nfunction normalizeTransformedFunctions(optsTransformFunctions) {\n  if (!optsTransformFunctions) {\n    return defaultTransformedFunctions;\n  }\n\n  return [...defaultTransformedFunctions, ...optsTransformFunctions];\n}\n\nfunction normalizeLoglevel(optsLoglevel) {\n  return optsLoglevel || 'warn';\n}\n\nvar _default = (0, _reselect.createSelector)( // The currentFile should have an extension; otherwise it's considered a special value\ncurrentFile => currentFile.includes('.') ? _path.default.dirname(currentFile) : currentFile, (_, opts) => opts, (currentFile, opts) => {\n  const cwd = normalizeCwd(opts.cwd, currentFile);\n  const root = normalizeRoot(opts.root, cwd);\n  const alias = normalizeAlias(opts.alias);\n  const loglevel = normalizeLoglevel(opts.loglevel);\n  const transformFunctions = normalizeTransformedFunctions(opts.transformFunctions);\n  const extensions = opts.extensions || defaultExtensions;\n  const stripExtensions = opts.stripExtensions || extensions;\n  const resolvePath = opts.resolvePath || _resolvePath.default;\n  return {\n    cwd,\n    root,\n    alias,\n    loglevel,\n    transformFunctions,\n    extensions,\n    stripExtensions,\n    resolvePath\n  };\n});\n\nexports.default = _default;","\n\nexports.__esModule = true;\nexports.nodeResolvePath = nodeResolvePath;\nexports.isRelativePath = isRelativePath;\nexports.toPosixPath = toPosixPath;\nexports.toLocalPath = toLocalPath;\nexports.stripExtension = stripExtension;\nexports.replaceExtension = replaceExtension;\nexports.matchesPattern = matchesPattern;\nexports.mapPathString = mapPathString;\nexports.isImportCall = isImportCall;\nexports.escapeRegExp = escapeRegExp;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _resolve = _interopRequireDefault(require(\"resolve\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction nodeResolvePath(modulePath, basedir, extensions) {\n  try {\n    return _resolve.default.sync(modulePath, {\n      basedir,\n      extensions\n    });\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction isRelativePath(nodePath) {\n  return nodePath.match(/^\\.?\\.\\//);\n}\n\nfunction toPosixPath(modulePath) {\n  return modulePath.replace(/\\\\/g, '/');\n}\n\nfunction toLocalPath(modulePath) {\n  let localPath = modulePath.replace(/\\/index$/, ''); // remove trailing /index\n\n  if (!isRelativePath(localPath)) {\n    localPath = `./${localPath}`; // insert `./` to make it a relative path\n  }\n\n  return localPath;\n}\n\nfunction stripExtension(modulePath, stripExtensions) {\n  let name = _path.default.basename(modulePath);\n\n  stripExtensions.some(extension => {\n    if (name.endsWith(extension)) {\n      name = name.slice(0, name.length - extension.length);\n      return true;\n    }\n\n    return false;\n  });\n  return name;\n}\n\nfunction replaceExtension(modulePath, opts) {\n  const filename = stripExtension(modulePath, opts.stripExtensions);\n  return _path.default.join(_path.default.dirname(modulePath), filename);\n}\n\nfunction matchesPattern(types, calleePath, pattern) {\n  const node = calleePath.node;\n\n  if (types.isMemberExpression(node)) {\n    return calleePath.matchesPattern(pattern);\n  }\n\n  if (!types.isIdentifier(node) || pattern.includes('.')) {\n    return false;\n  }\n\n  const name = pattern.split('.')[0];\n  return node.name === name;\n}\n\nfunction mapPathString(nodePath, state) {\n  if (!state.types.isStringLiteral(nodePath)) {\n    return;\n  }\n\n  const sourcePath = nodePath.node.value;\n  const currentFile = state.file.opts.filename;\n  const modulePath = state.normalizedOpts.resolvePath(sourcePath, currentFile, state.opts);\n\n  if (modulePath) {\n    if (nodePath.node.pathResolved) {\n      return;\n    }\n\n    nodePath.replaceWith(state.types.stringLiteral(modulePath));\n    nodePath.node.pathResolved = true;\n  }\n}\n\nfunction isImportCall(types, calleePath) {\n  return types.isImport(calleePath.node.callee);\n}\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}","\n\nexports.__esModule = true;\nexports.default = resolvePath;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _log = require(\"./log\");\n\nvar _mapToRelative = _interopRequireDefault(require(\"./mapToRelative\"));\n\nvar _normalizeOptions = _interopRequireDefault(require(\"./normalizeOptions\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getRelativePath(sourcePath, currentFile, absFileInRoot, opts) {\n  const realSourceFileExtension = _path.default.extname(absFileInRoot);\n\n  const sourceFileExtension = _path.default.extname(sourcePath);\n\n  let relativePath = (0, _mapToRelative.default)(opts.cwd, currentFile, absFileInRoot);\n\n  if (realSourceFileExtension !== sourceFileExtension) {\n    relativePath = (0, _utils.replaceExtension)(relativePath, opts);\n  }\n\n  return (0, _utils.toLocalPath)((0, _utils.toPosixPath)(relativePath));\n}\n\nfunction findPathInRoots(sourcePath, {\n  extensions,\n  root\n}) {\n  // Search the source path inside every custom root directory\n  let resolvedSourceFile;\n  root.some(basedir => {\n    resolvedSourceFile = (0, _utils.nodeResolvePath)(`./${sourcePath}`, basedir, extensions);\n    return resolvedSourceFile !== null;\n  });\n  return resolvedSourceFile;\n}\n\nfunction resolvePathFromRootConfig(sourcePath, currentFile, opts) {\n  const absFileInRoot = findPathInRoots(sourcePath, opts);\n\n  if (!absFileInRoot) {\n    return null;\n  }\n\n  return getRelativePath(sourcePath, currentFile, absFileInRoot, opts);\n}\n\nfunction checkIfPackageExists(modulePath, currentFile, extensions, loglevel) {\n  const resolvedPath = (0, _utils.nodeResolvePath)(modulePath, currentFile, extensions);\n\n  if (resolvedPath === null && loglevel !== 'silent') {\n    (0, _log.warn)(`Could not resolve \"${modulePath}\" in file ${currentFile}.`);\n  }\n}\n\nfunction resolvePathFromAliasConfig(sourcePath, currentFile, opts) {\n  let aliasedSourceFile;\n  opts.alias.find(([regExp, substitute]) => {\n    const execResult = regExp.exec(sourcePath);\n\n    if (execResult === null) {\n      return false;\n    }\n\n    aliasedSourceFile = substitute(execResult);\n    return true;\n  });\n\n  if (!aliasedSourceFile) {\n    return null;\n  }\n\n  if ((0, _utils.isRelativePath)(aliasedSourceFile)) {\n    return (0, _utils.toLocalPath)((0, _utils.toPosixPath)((0, _mapToRelative.default)(opts.cwd, currentFile, aliasedSourceFile)));\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    checkIfPackageExists(aliasedSourceFile, currentFile, opts.extensions, opts.loglevel);\n  }\n\n  return aliasedSourceFile;\n}\n\nconst resolvers = [resolvePathFromAliasConfig, resolvePathFromRootConfig];\n\nfunction resolvePath(sourcePath, currentFile, opts) {\n  if ((0, _utils.isRelativePath)(sourcePath)) {\n    return sourcePath;\n  }\n\n  const normalizedOpts = (0, _normalizeOptions.default)(currentFile, opts); // File param is a relative path from the environment current working directory\n  // (not from cwd param)\n\n  const absoluteCurrentFile = _path.default.resolve(currentFile);\n\n  let resolvedPath = null;\n  resolvers.some(resolver => {\n    resolvedPath = resolver(sourcePath, absoluteCurrentFile, normalizedOpts);\n    return resolvedPath !== null;\n  });\n  return resolvedPath;\n}","\n\nexports.__esModule = true;\nexports.warn = warn;\n\n// This module exists only for abstracting logging away and making testing easier\n// eslint-disable-next-line import/prefer-default-export\nfunction warn(...args) {\n  // eslint-disable-next-line no-console\n  console.warn(...args);\n}","\n\nexports.__esModule = true;\nexports.default = mapToRelative;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction mapToRelative(cwd, currentFile, module) {\n  let from = _path.default.dirname(currentFile);\n\n  let to = _path.default.normalize(module);\n\n  from = _path.default.resolve(cwd, from);\n  to = _path.default.resolve(cwd, to);\n\n  const moduleMapped = _path.default.relative(from, to);\n\n  return (0, _utils.toPosixPath)(moduleMapped);\n}","\n\nexports.__esModule = true;\nexports.default = transformCall;\n\nvar _utils = require(\"../utils\");\n\nfunction transformCall(nodePath, state) {\n  if (state.moduleResolverVisited.has(nodePath)) {\n    return;\n  }\n\n  const calleePath = nodePath.get('callee');\n  const isNormalCall = state.normalizedOpts.transformFunctions.some(pattern => (0, _utils.matchesPattern)(state.types, calleePath, pattern));\n\n  if (isNormalCall || (0, _utils.isImportCall)(state.types, nodePath)) {\n    state.moduleResolverVisited.add(nodePath);\n    (0, _utils.mapPathString)(nodePath.get('arguments.0'), state);\n  }\n}","\n\nexports.__esModule = true;\nexports.default = transformImport;\n\nvar _utils = require(\"../utils\");\n\nfunction transformImport(nodePath, state) {\n  if (state.moduleResolverVisited.has(nodePath)) {\n    return;\n  }\n\n  state.moduleResolverVisited.add(nodePath);\n  (0, _utils.mapPathString)(nodePath.get('source'), state);\n}"]}