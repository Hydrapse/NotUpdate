{"version":3,"sources":["index.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('nervjs');var Component = __TEMP__['Component'];var options = __TEMP__['options'];\n\n// tslint:disable-next-line\r\nvar global = (function () {\r\n    let local;\r\n    if (typeof global !== 'undefined') {\r\n        local = global;\r\n    }\r\n    else if (typeof self !== 'undefined') {\r\n        local = self;\r\n    }\r\n    else {\r\n        try {\r\n            // tslint:disable-next-line:function-constructor\r\n            local = Function('return this')();\r\n        }\r\n        catch (e) {\r\n            throw new Error('global object is unavailable in this environment');\r\n        }\r\n    }\r\n    return local;\r\n})();\r\nconst isBrowser = typeof window !== 'undefined';\r\n// tslint:disable-next-line:no-empty\r\nfunction noop$1() { }\r\nconst fakeDoc = {\r\n    createElement: noop$1,\r\n    createElementNS: noop$1,\r\n    createTextNode: noop$1\r\n};\r\nconst doc = isBrowser ? document : fakeDoc;\r\nconst UA = isBrowser && window.navigator.userAgent.toLowerCase();\r\nconst isMacSafari = isBrowser && UA && window.navigator.platform &&\r\n    /mac/i.test(window.navigator.platform) && /^((?!chrome|android).)*safari/i.test(UA);\r\nconst isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nconst isiOS = (UA && /iphone|ipad|ipod|ios/.test(UA));\n\nconst isSupportSVG = isFunction(doc.createAttributeNS);\r\nfunction isString(arg) {\r\n    return typeof arg === 'string';\r\n}\r\nfunction isFunction(arg) {\r\n    return typeof arg === 'function';\r\n}\r\nconst isArray = Array.isArray;\r\n/* istanbul ignore next */\r\n// tslint:disable-next-line\r\nObject.is = Object.is || function (x, y) {\r\n    if (x === y) {\r\n        return x !== 0 || 1 / x === 1 / y;\r\n    }\r\n    return x !== x && y !== y;\r\n};\n\nfunction getNodeType(vnode) {\r\n    if (isFunction(vnode.type)) {\r\n        return 'Composite';\r\n    }\r\n    else if (isString(vnode.type)) {\r\n        return 'Native';\r\n    }\r\n    return 'Text';\r\n}\r\nfunction getDisplayName(vnode) {\r\n    if (isFunction(vnode.type)) {\r\n        return vnode.type.displayName || vnode.type.name;\r\n    }\r\n    else if (isString(vnode.type)) {\r\n        return vnode.type;\r\n    }\r\n    return '#text';\r\n}\r\nfunction setIn(obj, path, value) {\r\n    const last = path.pop();\r\n    const parent = path.reduce((acc, attr) => (acc ? acc[attr] : null), obj);\r\n    if (parent) {\r\n        parent[last] = value;\r\n    }\r\n}\r\nfunction isEqual(a) {\r\n    return (b) => a === b;\r\n}\r\nfunction isRoot(vnode) {\r\n    return options.roots.some(isEqual(vnode));\r\n}\r\nfunction getInstance(vnode) {\r\n    if (vnode.component) {\r\n        return vnode.component;\r\n    }\r\n    return vnode.dom;\r\n}\r\nfunction shallowEqual(a, b, isProps) {\r\n    if (a == null || b == null) {\r\n        return false;\r\n    }\r\n    for (const key in a) {\r\n        if (isProps && key === 'children' && b[key] != null) {\r\n            continue;\r\n        }\r\n        if (a[key] !== b[key]) {\r\n            return false;\r\n        }\r\n    }\r\n    if (Object.keys(a).length !== Object.keys(b).length) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction hasDataChanged(prev, next) {\r\n    return ((prev.props !== next.props &&\r\n        !shallowEqual(prev.props, next.props, true)) ||\r\n        (prev.component != null &&\r\n            !shallowEqual(next.component.prevState, next.component.state)) ||\r\n        // prev.vnode.dom !== next.vnode.dom || @FIXME\r\n        prev.ref !== next.ref);\r\n}\r\nfunction getChildren(vnode) {\r\n    const c = vnode.component;\r\n    if (c == null) {\r\n        if (vnode.children) {\r\n            if (isArray(vnode.children)) {\r\n                return vnode.children.slice();\r\n            }\r\n            return [vnode.children];\r\n        }\r\n        return [];\r\n    }\r\n    return !Array.isArray(c._rendered) && c._rendered != null\r\n        ? [c._rendered]\r\n        : null;\r\n}\r\nfunction getData(_vnode) {\r\n    const vnode = _vnode instanceof Component ? _vnode.vnode : _vnode;\r\n    const component = vnode.component;\r\n    let updater = null;\r\n    if (component && component instanceof Component) {\r\n        updater = {\r\n            setState: component.setState.bind(component),\r\n            forceUpdate: component.forceUpdate.bind(component),\r\n            setInState(path, value) {\r\n                component.setState((prev) => {\r\n                    setIn(prev, path, value);\r\n                    return prev;\r\n                });\r\n            },\r\n            setInProps(path, value) {\r\n                setIn(vnode.props, path, value);\r\n                component.setState({});\r\n            },\r\n            setInContext(path, value) {\r\n                setIn(component.context, path, value);\r\n                component.setState({});\r\n            }\r\n        };\r\n    }\r\n    const duration = vnode.endTime - vnode.startTime;\r\n    const children = getChildren(vnode);\r\n    return {\r\n        nodeType: getNodeType(vnode),\r\n        type: vnode.type,\r\n        name: getDisplayName(vnode),\r\n        ref: vnode.ref || null,\r\n        key: vnode.key || null,\r\n        updater,\r\n        text: vnode.text,\r\n        state: component != null && component instanceof Component\r\n            ? component.state\r\n            : null,\r\n        props: vnode.props,\r\n        // The devtools inline text children if they are the only child\r\n        children: vnode.text == null\r\n            ? children != null && children.length === 1 && children[0].text != null\r\n                ? children[0].text\r\n                : children\r\n            : null,\r\n        publicInstance: getInstance(vnode),\r\n        memoizedInteractions: [],\r\n        // Profiler data\r\n        actualDuration: duration,\r\n        actualStartTime: vnode.startTime,\r\n        treeBaseDuration: duration\r\n    };\r\n}\n\nclass Renderer {\r\n    constructor(hook, rid) {\r\n        this.rid = rid;\r\n        this.hook = hook;\r\n        this.pending = [];\r\n        this.instMap = new WeakMap();\r\n        this.connected = false;\r\n    }\r\n    markConnected() {\r\n        this.connected = true;\r\n        this.flushPendingEvents();\r\n    }\r\n    flushPendingEvents() {\r\n        if (!this.connected) {\r\n            return;\r\n        }\r\n        const events = this.pending;\r\n        this.pending = [];\r\n        for (let i = 0; i < events.length; i++) {\r\n            const event = events[i];\r\n            this.hook.emit(event.type, event);\r\n        }\r\n    }\r\n    mount(vnode) {\r\n        this.instMap.set(getInstance(vnode), vnode);\r\n        const data = getData(vnode);\r\n        const work = [\r\n            {\r\n                internalInstance: vnode,\r\n                data,\r\n                renderer: this.rid,\r\n                type: 'mount'\r\n            }\r\n        ];\r\n        // Children must be mounted first\r\n        if (Array.isArray(data.children)) {\r\n            const stack = data.children.slice();\r\n            let item;\r\n            while ((item = stack.pop()) != null) {\r\n                const children = getChildren(item);\r\n                stack.push(...children);\r\n                this.instMap.set(getInstance(item), item);\r\n                const itemData = getData(item);\r\n                work.push({\r\n                    internalInstance: item,\r\n                    data: itemData,\r\n                    renderer: this.rid,\r\n                    type: 'mount'\r\n                });\r\n            }\r\n        }\r\n        for (let i = work.length; --i >= 0;) {\r\n            this.pending.push(work[i]);\r\n        }\r\n        // Special event if we have a root\r\n        if (isRoot(vnode)) {\r\n            this.pending.push({\r\n                internalInstance: vnode,\r\n                data,\r\n                renderer: this.rid,\r\n                type: 'root'\r\n            });\r\n        }\r\n    }\r\n    update(vnode) {\r\n        const data = getData(vnode);\r\n        // Children must be updated first\r\n        if (Array.isArray(data.children)) {\r\n            for (let i = 0; i < data.children.length; i++) {\r\n                const child = data.children[i];\r\n                const inst = getInstance(child);\r\n                const prevChild = this.instMap.get(inst);\r\n                if (prevChild == null) {\r\n                    this.mount(child);\r\n                }\r\n                else {\r\n                    this.update(child);\r\n                }\r\n                // Mutate child to keep referential equality intact\r\n                data.children[i] = this.instMap.get(inst);\r\n            }\r\n        }\r\n        const prev = this.instMap.get(data.publicInstance);\r\n        // The `updateProfileTimes` event is a faster version of `updated` and\r\n        // is processed much quicker inside the devtools extension.\r\n        if (!hasDataChanged(prev, vnode)) {\r\n            // Always assume profiling data has changed. When we skip an event here\r\n            // the devtools element picker will somehow break.\r\n            this.pending.push({\r\n                internalInstance: prev,\r\n                data,\r\n                renderer: this.rid,\r\n                type: 'updateProfileTimes'\r\n            });\r\n            return;\r\n        }\r\n        this.pending.push({\r\n            internalInstance: prev,\r\n            data,\r\n            renderer: this.rid,\r\n            type: 'update'\r\n        });\r\n    }\r\n    handleCommitFiberRoot(vnode) {\r\n        const inst = getInstance(vnode);\r\n        if (this.instMap.has(inst)) {\r\n            this.update(vnode);\r\n        }\r\n        else {\r\n            this.mount(vnode);\r\n        }\r\n        let root = null;\r\n        if (isRoot(vnode)) {\r\n            vnode.treeBaseDuration = 0;\r\n            root = vnode;\r\n        }\r\n        else {\r\n            // \"rootCommitted\" always needs the actual root node for the profiler\r\n            // to be able to collect timings. The `_ancestorComponent` property will\r\n            // point to a vnode for a root node.\r\n            root = vnode.component;\r\n            while (root._parentComponent != null) {\r\n                root = root._parentComponent;\r\n            }\r\n        }\r\n        this.pending.push({\r\n            internalInstance: root,\r\n            renderer: this.rid,\r\n            data: getData(root),\r\n            type: 'rootCommitted'\r\n        });\r\n        this.flushPendingEvents();\r\n        return vnode;\r\n    }\r\n    handleCommitFiberUnmount(vnode) {\r\n        const inst = getInstance(vnode);\r\n        this.instMap.delete(inst);\r\n        // Special case when unmounting a root (most prominently caused by webpack's\r\n        // `hot-module-reloading`). If this happens we need to unmount the virtual\r\n        // `Fragment` we're wrapping around each root just for the devtools.\r\n        this.pending.push({\r\n            internalInstance: vnode,\r\n            renderer: this.rid,\r\n            type: 'unmount'\r\n        });\r\n    }\r\n    getNativeFromReactElement(vnode) {\r\n        return vnode.dom;\r\n    }\r\n    getReactElementFromNative(dom) {\r\n        return this.instMap.get(dom) || null;\r\n    }\r\n    // Unused, but devtools expects it to be there\r\n    /* istanbul ignore next */\r\n    // tslint:disable-next-line: no-empty\r\n    walkTree() { }\r\n    // Unused, but devtools expects it to be there\r\n    /* istanbul ignore next */\r\n    // tslint:disable-next-line: no-empty\r\n    cleanup() { }\r\n}\n\n/**\r\n * Wrap function with generic error logging\r\n *\r\n * @param {*} fn\r\n * @returns\r\n */\r\nfunction catchErrors(fn) {\r\n    // tslint:disable-next-line: only-arrow-functions\r\n    return function (arg) {\r\n        try {\r\n            return fn(arg);\r\n        }\r\n        catch (e) {\r\n            /* istanbul ignore next */\r\n            console.error('The react devtools encountered an error');\r\n            /* istanbul ignore next */\r\n            console.error(e); // eslint-disable-line no-console\r\n        }\r\n    };\r\n}\r\n/* istanbul ignore next */\r\nconst noop = () => undefined;\r\nfunction initDevTools() {\r\n    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n    if (hook == null) {\r\n        return;\r\n    }\r\n    let onCommitRoot = noop;\r\n    let onCommitUnmount = noop;\r\n    // Initialize our custom renderer\r\n    const rid = Math.random()\r\n        .toString(16)\r\n        .slice(2);\r\n    const nervRenderer = new Renderer(hook, rid);\r\n    catchErrors(() => {\r\n        let isDev = false;\r\n        try {\r\n            isDev = process.env.NODE_ENV !== 'production';\r\n        }\r\n        catch (e) {\r\n            //\r\n        }\r\n        // Tell devtools which bundle type we run in\r\n        window.parent.postMessage({\r\n            source: 'react-devtools-detector',\r\n            reactBuildType: /* istanbul ignore next */ isDev\r\n                ? 'development'\r\n                : 'production'\r\n        }, '*');\r\n        const renderer = {\r\n            bundleType: /* istanbul ignore next */ isDev ? 1 : 0,\r\n            version: '16.5.2',\r\n            rendererPackageName: 'nerv',\r\n            // We don't need this, but the devtools `attachRenderer` function relys\r\n            // it being there.\r\n            findHostInstanceByFiber(vnode) {\r\n                return vnode.dom;\r\n            },\r\n            // We don't need this, but the devtools `attachRenderer` function relys\r\n            // it being there.\r\n            findFiberByHostInstance(instance) {\r\n                return nervRenderer.instMap.get(instance) || null;\r\n            }\r\n        };\r\n        hook._renderers[rid] = renderer;\r\n        // We can't bring our own `attachRenderer` function therefore we simply\r\n        // prevent the devtools from overwriting our custom renderer by creating\r\n        // a noop setter.\r\n        Object.defineProperty(hook.helpers, rid, {\r\n            get: () => nervRenderer,\r\n            set: () => {\r\n                if (!nervRenderer.connected) {\r\n                    helpers.markConnected();\r\n                }\r\n            }\r\n        });\r\n        const helpers = hook.helpers[rid];\r\n        // Tell the devtools that we are ready to start\r\n        hook.emit('renderer-attached', {\r\n            id: rid,\r\n            renderer,\r\n            helpers\r\n        });\r\n        onCommitRoot = catchErrors((root) => {\r\n            // Empty (root)\r\n            // if (root.type === Fragment && root._children.length == 0) return\r\n            const roots = hook.getFiberRoots(rid);\r\n            root = helpers.handleCommitFiberRoot(root);\r\n            if (!roots.has(root)) {\r\n                roots.add(root);\r\n            }\r\n        });\r\n        onCommitUnmount = catchErrors((vnode) => {\r\n            hook.onCommitFiberUnmount(rid, vnode);\r\n        });\r\n    })();\r\n    // Store (possible) previous hooks so that we don't overwrite them\r\n    // const prevVNodeHook = options.vnode\r\n    // const prevBeforeDiff = options.diff\r\n    // const prevAfterDiff = options.diffed\r\n    const prevAfterMount = options.afterMount;\r\n    const prevBeforeUnmount = options.beforeUnmount;\r\n    const prevAfterUpdate = options.afterUpdate;\r\n    const prevBeforeMount = options.beforeMount;\r\n    const prevBeforeUpdate = options.beforeUpdate;\r\n    const prevAfterCreate = options.afterCreate;\r\n    options.afterCreate = (vnode) => {\r\n        // Tiny performance improvement by initializing fields as doubles\r\n        // from the start. `performance.now()` will always return a double.\r\n        // See https://github.com/facebook/react/issues/14365\r\n        // and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\r\n        vnode.startTime = NaN;\r\n        vnode.endTime = NaN;\r\n        vnode.startTime = 0;\r\n        vnode.endTime = -1;\r\n        prevAfterCreate(vnode);\r\n    };\r\n    options.beforeMount = (vnode) => {\r\n        vnode.startTime = now();\r\n        prevBeforeMount(vnode);\r\n    };\r\n    options.beforeUpdate = (vnode) => {\r\n        vnode.startTime = now();\r\n        prevBeforeUpdate(vnode);\r\n    };\r\n    options.afterMount = catchErrors((vnode) => {\r\n        prevAfterMount(vnode);\r\n        // These cases are already handled by `unmount`\r\n        if (vnode == null) {\r\n            return;\r\n        }\r\n        onCommitRoot(vnode);\r\n    });\r\n    options.afterUpdate = catchErrors((vnode) => {\r\n        prevAfterUpdate(vnode);\r\n        // These cases are already handled by `unmount`\r\n        if (vnode == null) {\r\n            return;\r\n        }\r\n        vnode.endTime = now();\r\n        onCommitRoot(vnode);\r\n    });\r\n    options.beforeUnmount = catchErrors((vnode) => {\r\n        // Call previously defined hook\r\n        if (prevBeforeUnmount != null) {\r\n            prevBeforeUnmount(vnode);\r\n        }\r\n        onCommitUnmount(vnode);\r\n    });\r\n    // Inject tracking into setState\r\n    // const setState = Component.prototype.setState\r\n    // Component.prototype.setState = function (update, callback) {\r\n    //   // Duplicated in setState() but doesn't matter due to the guard.\r\n    //   const s =\r\n    //     (this._nextState !== this.state && this._nextState) ||\r\n    //     (this._nextState = {...this.state})\r\n    //   // Needed in order to check if state has changed after the tree has been committed:\r\n    //   this._prevState = {...s}\r\n    //   return setState.call(this, update, callback)\r\n    // }\r\n}\r\n/**\r\n * Get current timestamp in ms. Used for profiling.\r\n * @returns {number}\r\n */\r\nlet now = Date.now;\r\ntry {\r\n    /* istanbul ignore else */\r\n    now = performance.now.bind(performance);\r\n}\r\ncatch (e) {\r\n    //\r\n}\r\ninitDevTools();\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'initDevTools', { enumerable: true, configurable: true, get: function() { return initDevTools; } });Object.defineProperty(exports, 'now', { enumerable: true, configurable: true, get: function() { return now; } });\n//# sourceMappingURL=index.esm.js.map\n"]}