{"version":3,"sources":["Location.js","ExpoLocation.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('@unimodules/core');var EventEmitter = __TEMP__['EventEmitter'];var Platform = __TEMP__['Platform'];\nvar __TEMP__ = require('invariant');var invariant = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./ExpoLocation');var ExpoLocation = __REQUIRE_DEFAULT__(__TEMP__);\nconst LocationEventEmitter = new EventEmitter(ExpoLocation);\n;\nvar LocationAccuracy;\n(function (LocationAccuracy) {\n    LocationAccuracy[LocationAccuracy[\"Lowest\"] = 1] = \"Lowest\";\n    LocationAccuracy[LocationAccuracy[\"Low\"] = 2] = \"Low\";\n    LocationAccuracy[LocationAccuracy[\"Balanced\"] = 3] = \"Balanced\";\n    LocationAccuracy[LocationAccuracy[\"High\"] = 4] = \"High\";\n    LocationAccuracy[LocationAccuracy[\"Highest\"] = 5] = \"Highest\";\n    LocationAccuracy[LocationAccuracy[\"BestForNavigation\"] = 6] = \"BestForNavigation\";\n})(LocationAccuracy || (LocationAccuracy = {}));\nvar LocationActivityType;\n(function (LocationActivityType) {\n    LocationActivityType[LocationActivityType[\"Other\"] = 1] = \"Other\";\n    LocationActivityType[LocationActivityType[\"AutomotiveNavigation\"] = 2] = \"AutomotiveNavigation\";\n    LocationActivityType[LocationActivityType[\"Fitness\"] = 3] = \"Fitness\";\n    LocationActivityType[LocationActivityType[\"OtherNavigation\"] = 4] = \"OtherNavigation\";\n    LocationActivityType[LocationActivityType[\"Airborne\"] = 5] = \"Airborne\";\n})(LocationActivityType || (LocationActivityType = {}));\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'Accuracy', { enumerable: true, configurable: true, get: function() { return LocationAccuracy; } });Object.defineProperty(exports, 'ActivityType', { enumerable: true, configurable: true, get: function() { return LocationActivityType; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var GeofencingEventType = exports.GeofencingEventType = undefined;\n(function (GeofencingEventType) {\n    GeofencingEventType[GeofencingEventType[\"Enter\"] = 1] = \"Enter\";\n    GeofencingEventType[GeofencingEventType[\"Exit\"] = 2] = \"Exit\";\n})(GeofencingEventType || (GeofencingEventType = {}));\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var GeofencingRegionState = exports.GeofencingRegionState = undefined;\n(function (GeofencingRegionState) {\n    GeofencingRegionState[GeofencingRegionState[\"Unknown\"] = 0] = \"Unknown\";\n    GeofencingRegionState[GeofencingRegionState[\"Inside\"] = 1] = \"Inside\";\n    GeofencingRegionState[GeofencingRegionState[\"Outside\"] = 2] = \"Outside\";\n})(GeofencingRegionState || (GeofencingRegionState = {}));\nlet nextWatchId = 0;\nlet headingId;\nfunction _getNextWatchId() {\n    nextWatchId++;\n    return nextWatchId;\n}\nfunction _getCurrentWatchId() {\n    return nextWatchId;\n}\nlet watchCallbacks = {};\nlet deviceEventSubscription;\nlet headingEventSub;\nlet googleApiKey;\nconst googleApiUrl = 'https://maps.googleapis.com/maps/api/geocode/json';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getProviderStatusAsync = async function getProviderStatusAsync() {\n    return ExpoLocation.getProviderStatusAsync();\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.enableNetworkProviderAsync = async function enableNetworkProviderAsync() {\n    // If network provider is disabled (user's location mode is set to \"Device only\"),\n    // Android's location provider may not give you any results. Use this method in order to ask the user\n    // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\n    // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\n    if (Platform.OS === 'android') {\n        return ExpoLocation.enableNetworkProviderAsync();\n    }\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getCurrentPositionAsync = async function getCurrentPositionAsync(options = {}) {\n    return ExpoLocation.getCurrentPositionAsync(options);\n};\n// Start Compass Module\n// To simplify, we will call watchHeadingAsync and wait for one update To ensure accuracy, we wait\n// for a couple of watch updates if the data has low accuracy\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getHeadingAsync = async function getHeadingAsync() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            // If there is already a compass active (would be a watch)\n            if (headingEventSub) {\n                let tries = 0;\n                const headingSub = LocationEventEmitter.addListener('Expo.headingChanged', ({ heading }) => {\n                    if (heading.accuracy > 1 || tries > 5) {\n                        resolve(heading);\n                        LocationEventEmitter.removeSubscription(headingSub);\n                    }\n                    else {\n                        tries += 1;\n                    }\n                });\n            }\n            else {\n                let done = false;\n                let subscription;\n                let tries = 0;\n                subscription = await watchHeadingAsync((heading) => {\n                    if (!done) {\n                        if (heading.accuracy > 1 || tries > 5) {\n                            subscription.remove();\n                            resolve(heading);\n                            done = true;\n                        }\n                        else {\n                            tries += 1;\n                        }\n                    }\n                    else {\n                        subscription.remove();\n                    }\n                });\n                if (done) {\n                    subscription.remove();\n                }\n            }\n        }\n        catch (e) {\n            reject(e);\n        }\n    });\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.watchHeadingAsync = async function watchHeadingAsync(callback) {\n    // Check if there is already a compass event watch.\n    if (headingEventSub) {\n        _removeHeadingWatcher(headingId);\n    }\n    headingEventSub = LocationEventEmitter.addListener('Expo.headingChanged', ({ watchId, heading }) => {\n        const callback = watchCallbacks[watchId];\n        if (callback) {\n            callback(heading);\n        }\n        else {\n            ExpoLocation.removeWatchAsync(watchId);\n        }\n    });\n    headingId = _getNextWatchId();\n    watchCallbacks[headingId] = callback;\n    await ExpoLocation.watchDeviceHeading(headingId);\n    return {\n        remove() {\n            _removeHeadingWatcher(headingId);\n        },\n    };\n};\n// Removes the compass listener and sub from JS and Native\nfunction _removeHeadingWatcher(watchId) {\n    if (!watchCallbacks[watchId]) {\n        return;\n    }\n    delete watchCallbacks[watchId];\n    ExpoLocation.removeWatchAsync(watchId);\n    if (headingEventSub) {\n        LocationEventEmitter.removeSubscription(headingEventSub);\n        headingEventSub = null;\n    }\n}\n// End Compass Module\nfunction _maybeInitializeEmitterSubscription() {\n    if (!deviceEventSubscription) {\n        deviceEventSubscription = LocationEventEmitter.addListener('Expo.locationChanged', ({ watchId, location }) => {\n            const callback = watchCallbacks[watchId];\n            if (callback) {\n                callback(location);\n            }\n            else {\n                ExpoLocation.removeWatchAsync(watchId);\n            }\n        });\n    }\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.geocodeAsync = async function geocodeAsync(address) {\n    return ExpoLocation.geocodeAsync(address).catch(error => {\n        const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n        if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n            if (!googleApiKey) {\n                throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n            }\n            return _googleGeocodeAsync(address);\n        }\n        throw error;\n    });\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.reverseGeocodeAsync = async function reverseGeocodeAsync(location) {\n    if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\n        throw new TypeError('Location should be an object with number properties `latitude` and `longitude`.');\n    }\n    return ExpoLocation.reverseGeocodeAsync(location).catch(error => {\n        const platformUsesGoogleMaps = Platform.OS === 'android' || Platform.OS === 'web';\n        if (platformUsesGoogleMaps && error.code === 'E_NO_GEOCODER') {\n            if (!googleApiKey) {\n                throw new Error(error.message + ' Please set a Google API Key to use geocoding.');\n            }\n            return _googleReverseGeocodeAsync(location);\n        }\n        throw error;\n    });\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.setApiKey = function setApiKey(apiKey) {\n    googleApiKey = apiKey;\n};\nasync function _googleGeocodeAsync(address) {\n    const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&address=${encodeURI(address)}`);\n    const resultObject = await result.json();\n    const { status } = resultObject;\n    if (status === 'ZERO_RESULTS') {\n        return [];\n    }\n    else if (status !== 'OK') {\n        throw new Error(`An error occurred during geocoding. ${status}`);\n    }\n    return resultObject.results.map(result => {\n        let location = result.geometry.location;\n        // TODO: This is missing a lot of props\n        return {\n            latitude: location.lat,\n            longitude: location.lng,\n        };\n    });\n}\nasync function _googleReverseGeocodeAsync(options) {\n    const result = await fetch(`${googleApiUrl}?key=${googleApiKey}&latlng=${options.latitude},${options.longitude}`);\n    const resultObject = await result.json();\n    if (resultObject.status !== 'OK') {\n        throw new Error('An error occurred during geocoding.');\n    }\n    return resultObject.results.map(result => {\n        const address = {};\n        result.address_components.forEach(component => {\n            if (component.types.includes('locality')) {\n                address.city = component.long_name;\n            }\n            else if (component.types.includes('street_address')) {\n                address.street = component.long_name;\n            }\n            else if (component.types.includes('administrative_area_level_1')) {\n                address.region = component.long_name;\n            }\n            else if (component.types.includes('country')) {\n                address.country = component.long_name;\n            }\n            else if (component.types.includes('postal_code')) {\n                address.postalCode = component.long_name;\n            }\n            else if (component.types.includes('point_of_interest')) {\n                address.name = component.long_name;\n            }\n        });\n        return address;\n    });\n}\n// Polyfill: navigator.geolocation.watchPosition\nfunction watchPosition(success, error, options) {\n    _maybeInitializeEmitterSubscription();\n    const watchId = _getNextWatchId();\n    watchCallbacks[watchId] = success;\n    ExpoLocation.watchPositionImplAsync(watchId, options).catch(err => {\n        _removeWatcher(watchId);\n        error({ watchId, message: err.message, code: err.code });\n    });\n    return watchId;\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.watchPositionAsync = async function watchPositionAsync(options, callback) {\n    _maybeInitializeEmitterSubscription();\n    const watchId = _getNextWatchId();\n    watchCallbacks[watchId] = callback;\n    await ExpoLocation.watchPositionImplAsync(watchId, options);\n    return {\n        remove() {\n            _removeWatcher(watchId);\n        },\n    };\n};\n// Polyfill: navigator.geolocation.clearWatch\nfunction clearWatch(watchId) {\n    _removeWatcher(watchId);\n}\nfunction _removeWatcher(watchId) {\n    // Do nothing if we have already removed the subscription\n    if (!watchCallbacks[watchId]) {\n        return;\n    }\n    ExpoLocation.removeWatchAsync(watchId);\n    delete watchCallbacks[watchId];\n    if (Object.keys(watchCallbacks).length === 0 && deviceEventSubscription) {\n        LocationEventEmitter.removeSubscription(deviceEventSubscription);\n        deviceEventSubscription = null;\n    }\n}\nfunction getCurrentPosition(success, error = () => { }, options = {}) {\n    invariant(typeof success === 'function', 'Must provide a valid success callback.');\n    invariant(typeof options === 'object', 'options must be an object.');\n    _getCurrentPositionAsyncWrapper(success, error, options);\n}\n// This function exists to let us continue to return undefined from getCurrentPosition, while still\n// using async/await for the internal implementation of it\nasync function _getCurrentPositionAsyncWrapper(success, error, options) {\n    try {\n        await ExpoLocation.requestPermissionsAsync();\n        const result = await getCurrentPositionAsync(options);\n        success(result);\n    }\n    catch (e) {\n        error(e);\n    }\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.requestPermissionsAsync = async function requestPermissionsAsync() {\n    await ExpoLocation.requestPermissionsAsync();\n};\n// --- Location service\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.hasServicesEnabledAsync = async function hasServicesEnabledAsync() {\n    return await ExpoLocation.hasServicesEnabledAsync();\n};\n// --- Background location updates\nfunction _validateTaskName(taskName) {\n    invariant(taskName && typeof taskName === 'string', '`taskName` must be a non-empty string.');\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.isBackgroundLocationAvailableAsync = async function isBackgroundLocationAvailableAsync() {\n    const providerStatus = await getProviderStatusAsync();\n    return providerStatus.backgroundModeEnabled;\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.startLocationUpdatesAsync = async function startLocationUpdatesAsync(taskName, options = { accuracy: LocationAccuracy.Balanced }) {\n    _validateTaskName(taskName);\n    await ExpoLocation.startLocationUpdatesAsync(taskName, options);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.stopLocationUpdatesAsync = async function stopLocationUpdatesAsync(taskName) {\n    _validateTaskName(taskName);\n    await ExpoLocation.stopLocationUpdatesAsync(taskName);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.hasStartedLocationUpdatesAsync = async function hasStartedLocationUpdatesAsync(taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\n};\n// --- Geofencing\nfunction _validateRegions(regions) {\n    if (!regions || regions.length === 0) {\n        throw new Error('Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions');\n    }\n    for (const region of regions) {\n        if (typeof region.latitude !== 'number') {\n            throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\n        }\n        if (typeof region.longitude !== 'number') {\n            throw new TypeError(`Region's longitude must be a number. Got '${region.longitude}' instead.`);\n        }\n        if (typeof region.radius !== 'number') {\n            throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\n        }\n    }\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.startGeofencingAsync = async function startGeofencingAsync(taskName, regions = []) {\n    _validateTaskName(taskName);\n    _validateRegions(regions);\n    await ExpoLocation.startGeofencingAsync(taskName, { regions });\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.stopGeofencingAsync = async function stopGeofencingAsync(taskName) {\n    _validateTaskName(taskName);\n    await ExpoLocation.stopGeofencingAsync(taskName);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.hasStartedGeofencingAsync = async function hasStartedGeofencingAsync(taskName) {\n    _validateTaskName(taskName);\n    return ExpoLocation.hasStartedGeofencingAsync(taskName);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.installWebGeolocationPolyfill = function installWebGeolocationPolyfill() {\n    if (Platform.OS !== 'web') {\n        // Polyfill navigator.geolocation for interop with the core react-native and web API approach to\n        // geolocation\n        // @ts-ignore\n        window.navigator.geolocation = {\n            getCurrentPosition,\n            watchPosition,\n            clearWatch,\n            // We don't polyfill stopObserving, this is an internal method that probably should not even exist\n            // in react-native docs\n            stopObserving: () => { },\n        };\n    }\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'EventEmitter', { enumerable: true, configurable: true, get: function() { return LocationEventEmitter; } });Object.defineProperty(exports, '_getCurrentWatchId', { enumerable: true, configurable: true, get: function() { return _getCurrentWatchId; } });\n\n\n//# sourceMappingURL=Location.js.map","var __TEMP__ = require('@unimodules/core');var NativeModulesProxy = __TEMP__['NativeModulesProxy'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = NativeModulesProxy.ExpoLocation;\n//# sourceMappingURL=ExpoLocation.js.map"]}