{"version":3,"sources":["index.js","dist/index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./dist/index.js').default\nmodule.exports.default = module.exports\n","\n\n// tslint:disable-next-line\nvar global = function () {\n    var local;\n    if (typeof global !== 'undefined') {\n        local = global;\n    } else if (typeof self !== 'undefined') {\n        local = self;\n    } else {\n        try {\n            // tslint:disable-next-line:function-constructor\n            local = Function('return this')();\n        } catch (e) {\n            throw new Error('global object is unavailable in this environment');\n        }\n    }\n    return local;\n}();\nvar isBrowser = typeof window !== 'undefined';\n// tslint:disable-next-line:no-empty\nfunction noop() {}\nvar fakeDoc = {\n    createElement: noop,\n    createElementNS: noop,\n    createTextNode: noop\n};\nvar doc = isBrowser ? document : fakeDoc;\nvar UA = isBrowser && window.navigator.userAgent.toLowerCase();\nvar isMacSafari = isBrowser && UA && window.navigator.platform && /mac/i.test(window.navigator.platform) && /^((?!chrome|android).)*safari/i.test(UA);\nvar isTaro = isBrowser && !document.scripts;\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isiOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\nfunction isNumber(arg) {\n    return typeof arg === 'number';\n}\nvar isSupportSVG = isFunction(doc.createAttributeNS);\nfunction isString(arg) {\n    return typeof arg === 'string';\n}\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction isBoolean(arg) {\n    return arg === true || arg === false;\n}\nvar isArray = Array.isArray;\nfunction isObject(arg) {\n    return arg === Object(arg) && !isFunction(arg);\n}\nfunction isUndefined(o) {\n    return o === undefined;\n}\n// Object.is polyfill\n// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\nfunction objectIs(x, y) {\n    if (x === y) {\n        // Steps 1-5, 7-10\n        // Steps 6.b-6.e: +0 != -0\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    // eslint-disable-next-line no-self-compare\n    return x !== x && y !== y;\n}\n\nvar canUsePromise = 'Promise' in global && !isMacSafari;\nvar resolved;\nif (canUsePromise) {\n    resolved = Promise.resolve();\n}\nvar nextTick = function (fn) {\n    var args = [],\n        len = arguments.length - 1;\n    while (len-- > 0) args[len] = arguments[len + 1];\n\n    fn = isFunction(fn) ? fn.bind.apply(fn, [null].concat(args)) : fn;\n    if (canUsePromise) {\n        return resolved.then(fn);\n    }\n    var timerFunc = 'requestAnimationFrame' in global && !isMacSafari ? requestAnimationFrame : setTimeout;\n    timerFunc(fn);\n};\n\n/* istanbul ignore next */\n// tslint:disable-next-line\nObject.is = Object.is || function (x, y) {\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y;\n    }\n    return x !== x && y !== y;\n};\nfunction shallowEqual(obj1, obj2) {\n    if (obj1 === null || obj2 === null) {\n        return false;\n    }\n    if (Object.is(obj1, obj2)) {\n        return true;\n    }\n    var obj1Keys = obj1 ? Object.keys(obj1) : [];\n    var obj2Keys = obj2 ? Object.keys(obj2) : [];\n    if (obj1Keys.length !== obj2Keys.length) {\n        return false;\n    }\n    for (var i = 0; i < obj1Keys.length; i++) {\n        var obj1KeyItem = obj1Keys[i];\n        if (!obj2.hasOwnProperty(obj1KeyItem) || !Object.is(obj1[obj1KeyItem], obj2[obj1KeyItem])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvar SimpleMap = function SimpleMap() {\n    this.cache = [];\n    this.size = 0;\n};\nSimpleMap.prototype.set = function set(k, v) {\n    var this$1 = this;\n\n    var len = this.cache.length;\n    if (!len) {\n        this.cache.push({ k: k, v: v });\n        this.size += 1;\n        return;\n    }\n    for (var i = 0; i < len; i++) {\n        var item = this$1.cache[i];\n        if (item.k === k) {\n            item.v = v;\n            return;\n        }\n    }\n    this.cache.push({ k: k, v: v });\n    this.size += 1;\n};\nSimpleMap.prototype.get = function get(k) {\n    var this$1 = this;\n\n    var len = this.cache.length;\n    if (!len) {\n        return;\n    }\n    for (var i = 0; i < len; i++) {\n        var item = this$1.cache[i];\n        if (item.k === k) {\n            return item.v;\n        }\n    }\n};\nSimpleMap.prototype.has = function has(k) {\n    var this$1 = this;\n\n    var len = this.cache.length;\n    if (!len) {\n        return false;\n    }\n    for (var i = 0; i < len; i++) {\n        var item = this$1.cache[i];\n        if (item.k === k) {\n            return true;\n        }\n    }\n    return false;\n};\nSimpleMap.prototype['delete'] = function delete$1(k) {\n    var this$1 = this;\n\n    var len = this.cache.length;\n    for (var i = 0; i < len; i++) {\n        var item = this$1.cache[i];\n        if (item.k === k) {\n            this$1.cache.splice(i, 1);\n            this$1.size -= 1;\n            return true;\n        }\n    }\n    return false;\n};\nSimpleMap.prototype.clear = function clear() {\n    var this$1 = this;\n\n    var len = this.cache.length;\n    this.size = 0;\n    if (!len) {\n        return;\n    }\n    while (len) {\n        this$1.cache.pop();\n        len--;\n    }\n};\nvar MapClass = 'Map' in global ? Map : SimpleMap;\n\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n';\n}\nvar extend = function () {\n    if ('assign' in Object) {\n        return function (source, from) {\n            if (!from) {\n                return source;\n            }\n            Object.assign(source, from);\n            return source;\n        };\n    } else {\n        return function (source, from) {\n            if (!from) {\n                return source;\n            }\n            for (var key in from) {\n                if (from.hasOwnProperty(key)) {\n                    source[key] = from[key];\n                }\n            }\n            return source;\n        };\n    }\n}();\nfunction clone(obj) {\n    return extend({}, obj);\n}\n\nvar Current = {\n    current: null,\n    index: 0\n};\n\nvar EMPTY_CHILDREN = [];\nvar EMPTY_OBJ = {};\nfunction isNullOrUndef(o) {\n    return o === undefined || o === null;\n}\nfunction isInvalid(o) {\n    return isNullOrUndef(o) || o === true || o === false;\n}\nfunction isVNode(node) {\n    return !isNullOrUndef(node) && node.vtype === 2 /* Node */;\n}\nfunction isVText(node) {\n    return !isNullOrUndef(node) && node.vtype === 1 /* Text */;\n}\nfunction isComponent(instance) {\n    return !isInvalid(instance) && instance.isReactComponent === EMPTY_OBJ;\n}\nfunction isPortal(vtype, node) {\n    return (vtype & 32 /* Portal */) > 0;\n}\nfunction isComposite(node) {\n    return !isNullOrUndef(node) && node.vtype === 4 /* Composite */;\n}\nfunction isValidElement(node) {\n    return !isNullOrUndef(node) && node.vtype;\n}\n// tslint:disable-next-line:no-empty\nfunction noop$1() {}\n// typescript will compile the enum's value for us.\n// eg.\n// Composite = 1 << 2  => Composite = 4\nvar VType;\n(function (VType) {\n    VType[VType[\"Text\"] = 1] = \"Text\";\n    VType[VType[\"Node\"] = 2] = \"Node\";\n    VType[VType[\"Composite\"] = 4] = \"Composite\";\n    VType[VType[\"Void\"] = 16] = \"Void\";\n    VType[VType[\"Portal\"] = 32] = \"Portal\";\n})(VType || (VType = {}));\n\nvar Ref = {\n    update: function update(lastVnode, nextVnode, domNode) {\n        var prevRef = lastVnode != null && lastVnode.ref;\n        var nextRef = nextVnode != null && nextVnode.ref;\n        if (prevRef !== nextRef) {\n            this.detach(lastVnode, prevRef, lastVnode.dom);\n            this.attach(nextVnode, nextRef, domNode);\n        }\n    },\n    attach: function attach(vnode, ref, domNode) {\n        var node = isComposite(vnode) ? vnode.component : domNode;\n        if (isFunction(ref)) {\n            var componentForCatcher = isComposite(vnode) ? vnode.component : vnode;\n            errorCatcher(function () {\n                ref(node);\n            }, componentForCatcher);\n        } else if (isString(ref)) {\n            var inst = vnode._owner;\n            if (inst && isFunction(inst.render)) {\n                inst.refs[ref] = node;\n            }\n        } else if (isObject(ref)) {\n            ref.current = node;\n        }\n    },\n    detach: function detach(vnode, ref, domNode) {\n        var node = isComposite(vnode) ? vnode.component : domNode;\n        if (isFunction(ref)) {\n            var componentForCatcher = isComposite(vnode) ? vnode.component : vnode;\n            errorCatcher(function () {\n                ref(null);\n            }, componentForCatcher);\n        } else if (isString(ref)) {\n            var inst = vnode._owner;\n            if (inst.refs[ref] === node && isFunction(inst.render)) {\n                delete inst.refs[ref];\n            }\n        } else if (isObject(ref)) {\n            ref.current = null;\n        }\n    }\n};\n\nvar defaultOptions = {\n    passive: false,\n    capture: false\n};\nvar eventListenerOptionsSupported = function () {\n    var supported = false;\n    try {\n        var opts = Object.defineProperty({}, 'passive', {\n            get: function get() {\n                supported = true;\n            }\n        });\n        window.addEventListener('test', null, opts);\n        window.removeEventListener('test', null, opts);\n    } catch (e) {\n        supported = false;\n    }\n    return supported;\n};\nfunction getDefaultPassiveOption() {\n    var passiveOption = !eventListenerOptionsSupported() ? false : defaultOptions;\n    return function () {\n        return passiveOption;\n    };\n}\nvar getPassiveOption = getDefaultPassiveOption();\nvar supportedPassiveEventMap = {\n    scroll: getPassiveOption(),\n    wheel: getPassiveOption(),\n    touchstart: getPassiveOption(),\n    touchmove: getPassiveOption(),\n    touchenter: getPassiveOption(),\n    touchend: getPassiveOption(),\n    touchleave: getPassiveOption(),\n    mouseout: getPassiveOption(),\n    mouseleave: getPassiveOption(),\n    mouseup: getPassiveOption(),\n    mousedown: getPassiveOption(),\n    mousemove: getPassiveOption(),\n    mouseenter: getPassiveOption(),\n    mousewheel: getPassiveOption(),\n    mouseover: getPassiveOption()\n};\n\nvar ONINPUT = 'oninput';\nvar ONPROPERTYCHANGE = 'onpropertychange';\nvar delegatedEvents = new MapClass();\nvar unbubbleEvents = {\n    onmousemove: 1,\n    ontouchmove: 1,\n    onmouseleave: 1,\n    onmouseenter: 1,\n    onload: 1,\n    onunload: 1,\n    onscroll: 1,\n    onfocus: 1,\n    onblur: 1,\n    onrowexit: 1,\n    onbeforeunload: 1,\n    onstop: 1,\n    ondragdrop: 1,\n    ondragenter: 1,\n    ondragexit: 1,\n    ondraggesture: 1,\n    ondragover: 1,\n    oncontextmenu: 1,\n    onerror: 1,\n    onabort: 1,\n    oncanplay: 1,\n    oncanplaythrough: 1,\n    ondurationchange: 1,\n    onemptied: 1,\n    onended: 1,\n    onloadeddata: 1,\n    onloadedmetadata: 1,\n    onloadstart: 1,\n    onencrypted: 1,\n    onpause: 1,\n    onplay: 1,\n    onplaying: 1,\n    onprogress: 1,\n    onratechange: 1,\n    onseeking: 1,\n    onseeked: 1,\n    onstalled: 1,\n    onsuspend: 1,\n    ontimeupdate: 1,\n    onvolumechange: 1,\n    onwaiting: 1\n};\nunbubbleEvents[ONPROPERTYCHANGE] = 1;\nvar bindFocus = false;\n/* istanbul ignore next */\nif (isIE9) {\n    var elements = [];\n    var values = [];\n    doc.addEventListener('selectionchange', function () {\n        var el = doc.activeElement;\n        if (detectCanUseOnInputNode(el)) {\n            var index = elements.indexOf(el);\n            var element = elements[index] || elements.push(el);\n            if (element.value !== values[index]) {\n                var ev = doc.createEvent('CustomEvent');\n                ev.initCustomEvent('input', true, true, undefined);\n                values[index] = element.value;\n                el.dispatchEvent(ev);\n            }\n        }\n    });\n}\nif (typeof Event !== 'undefined' && !Event.prototype.persist) {\n    // tslint:disable-next-line:no-empty\n    Event.prototype.persist = noop$1;\n}\nfunction attachEvent(domNode, eventName, handler) {\n    eventName = fixEvent(domNode, eventName);\n    /* istanbul ignore next */\n    if (eventName === ONPROPERTYCHANGE) {\n        processOnPropertyChangeEvent(domNode, handler);\n        return;\n    }\n    var delegatedRoots = delegatedEvents.get(eventName);\n    if (unbubbleEvents[eventName] === 1 || isTaro) {\n        if (!delegatedRoots) {\n            delegatedRoots = new MapClass();\n        }\n        var event = attachEventToNode(domNode, eventName, delegatedRoots);\n        delegatedEvents.set(eventName, delegatedRoots);\n        if (isFunction(handler)) {\n            delegatedRoots.set(domNode, {\n                eventHandler: handler,\n                event: event\n            });\n        }\n    } else {\n        if (!delegatedRoots) {\n            delegatedRoots = {\n                items: new MapClass()\n            };\n            delegatedRoots.event = attachEventToDocument(doc, eventName, delegatedRoots);\n            delegatedEvents.set(eventName, delegatedRoots);\n        }\n        if (isFunction(handler)) {\n            if (isiOS) {\n                domNode.onclick = noop$1;\n            }\n            delegatedRoots.items.set(domNode, handler);\n        }\n    }\n}\nfunction detachEvent(domNode, eventName, handler) {\n    eventName = fixEvent(domNode, eventName);\n    if (eventName === ONPROPERTYCHANGE) {\n        return;\n    }\n    var delegatedRoots = delegatedEvents.get(eventName);\n    if (unbubbleEvents[eventName] === 1 && delegatedRoots || isTaro) {\n        var event = delegatedRoots.get(domNode);\n        if (event) {\n            domNode.removeEventListener(parseEventName(eventName), event.event, false);\n            /* istanbul ignore next */\n            var delegatedRootsSize = delegatedRoots.size;\n            if (delegatedRoots['delete'](domNode) && delegatedRootsSize === 0) {\n                delegatedEvents['delete'](eventName);\n            }\n        }\n    } else if (delegatedRoots && delegatedRoots.items) {\n        var items = delegatedRoots.items;\n        if (items['delete'](domNode) && items.size === 0) {\n            doc.removeEventListener(parseEventName(eventName), delegatedRoots.event, false);\n            delegatedEvents['delete'](eventName);\n        }\n    }\n}\nvar propertyChangeActiveElement;\nvar propertyChangeActiveElementValue;\nvar propertyChangeActiveElementValueProp;\nvar propertyChangeActiveHandlers = {};\n/* istanbul ignore next */\nfunction propertyChangeHandler(event) {\n    if (event.propertyName !== 'value') {\n        return;\n    }\n    var target = event.target || event.srcElement;\n    var val = target.value;\n    if (val === propertyChangeActiveElementValue) {\n        return;\n    }\n    propertyChangeActiveElementValue = val;\n    var handler = propertyChangeActiveHandlers[target.name];\n    if (isFunction(handler)) {\n        handler.call(target, event);\n    }\n}\n/* istanbul ignore next */\nfunction processOnPropertyChangeEvent(node, handler) {\n    propertyChangeActiveHandlers[node.name] = handler;\n    if (!bindFocus) {\n        // bindFocus = true\n        node.addEventListener('focusin', function () {\n            unbindOnPropertyChange();\n            bindOnPropertyChange(node);\n        }, false);\n        node.addEventListener('focusout', unbindOnPropertyChange, false);\n    }\n}\n/* istanbul ignore next */\nfunction bindOnPropertyChange(node) {\n    propertyChangeActiveElement = node;\n    propertyChangeActiveElementValue = node.value;\n    propertyChangeActiveElementValueProp = Object.getOwnPropertyDescriptor(node.constructor.prototype, 'value');\n    Object.defineProperty(propertyChangeActiveElement, 'value', {\n        get: function get() {\n            return propertyChangeActiveElementValueProp.get.call(this);\n        },\n        set: function set(val) {\n            propertyChangeActiveElementValue = val;\n            propertyChangeActiveElementValueProp.set.call(this, val);\n        }\n    });\n    propertyChangeActiveElement.addEventListener('propertychange', propertyChangeHandler, false);\n}\n/* istanbul ignore next */\nfunction unbindOnPropertyChange() {\n    if (!propertyChangeActiveElement) {\n        return;\n    }\n    delete propertyChangeActiveElement.value;\n    propertyChangeActiveElement.removeEventListener('propertychange', propertyChangeHandler, false);\n    propertyChangeActiveElement = null;\n    propertyChangeActiveElementValue = null;\n    propertyChangeActiveElementValueProp = null;\n}\nfunction detectCanUseOnInputNode(node) {\n    var nodeName = node.nodeName && node.nodeName.toLowerCase();\n    var type = node.type;\n    return nodeName === 'input' && /text|password/.test(type) || nodeName === 'textarea';\n}\nfunction fixEvent(node, eventName) {\n    if (isTaro && eventName === 'onClick') {\n        eventName = 'onTap';\n    }\n    if (eventName === 'onDoubleClick') {\n        eventName = 'ondblclick';\n    } else if (eventName === 'onTouchTap') {\n        eventName = 'onclick';\n        // tslint:disable-next-line:prefer-conditional-expression\n    } else if (eventName === 'onChange' && detectCanUseOnInputNode(node)) {\n        eventName = ONINPUT in window ? ONINPUT : ONPROPERTYCHANGE;\n    } else {\n        eventName = eventName.toLowerCase();\n    }\n    return eventName;\n}\nfunction parseEventName(name) {\n    return name.substr(2);\n}\n/* istanbul ignore next */\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    this.stopImmediatePropagation();\n}\nfunction dispatchEvent(event, target, items, count, eventData) {\n    var eventsToTrigger = items.get(target);\n    if (eventsToTrigger) {\n        count--;\n        eventData.currentTarget = target;\n        // for React synthetic event compatibility\n        Object.defineProperties(event, {\n            nativeEvent: {\n                value: event\n            }\n        });\n        eventsToTrigger(event);\n        if (event.cancelBubble) {\n            return;\n        }\n    }\n    if (count > 0) {\n        var parentDom = target.parentNode;\n        if (parentDom === null || event.type === 'click' && parentDom.nodeType === 1 && parentDom.disabled) {\n            return;\n        }\n        dispatchEvent(event, parentDom, items, count, eventData);\n    }\n}\nfunction attachEventToDocument(d, eventName, delegatedRoots) {\n    var eventHandler = function (event) {\n        var items = delegatedRoots.items;\n        var count = items.size;\n        if (count > 0) {\n            var eventData = {\n                currentTarget: event.target\n            };\n            /* istanbul ignore next */\n            try {\n                Object.defineProperties(event, {\n                    currentTarget: {\n                        configurable: true,\n                        get: function get() {\n                            return eventData.currentTarget;\n                        }\n                    },\n                    stopPropagation: {\n                        value: stopPropagation\n                    }\n                });\n            } catch (error) {\n                // some browsers crashed\n                // see: https://stackoverflow.com/questions/44052813/why-cannot-redefine-property\n            }\n            dispatchEvent(event, event.target, delegatedRoots.items, count, eventData);\n        }\n    };\n    var parsedEventName = parseEventName(eventName);\n    d.addEventListener(parsedEventName, eventHandler, supportedPassiveEventMap[parsedEventName] || false);\n    return eventHandler;\n}\nfunction attachEventToNode(node, eventName, delegatedRoots) {\n    var eventHandler = function (event) {\n        var eventToTrigger = delegatedRoots.get(node);\n        if (eventToTrigger && eventToTrigger.eventHandler) {\n            var eventData = {\n                currentTarget: node\n            };\n            /* istanbul ignore next */\n            Object.defineProperties(event, {\n                currentTarget: {\n                    configurable: true,\n                    get: function get() {\n                        return eventData.currentTarget;\n                    }\n                }\n            });\n            eventToTrigger.eventHandler(event);\n        }\n    };\n    var parsedEventName = parseEventName(eventName);\n    node.addEventListener(parsedEventName, eventHandler, supportedPassiveEventMap[parsedEventName] || false);\n    return eventHandler;\n}\n\nfunction unmountChildren(children, parentDom) {\n    if (isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            unmount(children[i], parentDom);\n        }\n    } else {\n        unmount(children, parentDom);\n    }\n}\nfunction unmount(vnode, parentDom) {\n    if (isInvalid(vnode)) {\n        return;\n    }\n    var vtype = vnode.vtype;\n    // Bitwise operators for better performance\n    // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\n    var dom = vnode.dom;\n    if ((vtype & 4 /* Composite */) > 0) {\n        vnode.destroy();\n    } else if ((vtype & 2 /* Node */) > 0) {\n        var props = vnode.props;\n        var children = vnode.children;\n        var ref = vnode.ref;\n        unmountChildren(children);\n        for (var propName in props) {\n            if (isAttrAnEvent(propName)) {\n                detachEvent(dom, propName, props[propName]);\n            }\n        }\n        if (ref !== null) {\n            Ref.detach(vnode, ref, dom);\n        }\n    } else if (vtype & 32 /* Portal */) {\n            unmountChildren(vnode.children, vnode.type);\n        }\n    if (!isNullOrUndef(parentDom) && !isNullOrUndef(dom)) {\n        if (isArray(dom)) {\n            for (var i = 0; i < dom.length; i++) {\n                parentDom.removeChild(dom[i]);\n            }\n        } else {\n            parentDom.removeChild(dom);\n        }\n    }\n    // vnode.dom = null\n}\n\nvar NS = {\n    ev: 'http://www.w3.org/2001/xml-events',\n    xlink: 'http://www.w3.org/1999/xlink',\n    xml: 'http://www.w3.org/XML/1998/namespace'\n};\nvar ATTRS = {\n    accentHeight: 'accent-height',\n    accumulate: 0,\n    additive: 0,\n    alignmentBaseline: 'alignment-baseline',\n    allowReorder: 'allowReorder',\n    alphabetic: 0,\n    amplitude: 0,\n    arabicForm: 'arabic-form',\n    ascent: 0,\n    attributeName: 'attributeName',\n    attributeType: 'attributeType',\n    autoReverse: 'autoReverse',\n    azimuth: 0,\n    baseFrequency: 'baseFrequency',\n    baseProfile: 'baseProfile',\n    baselineShift: 'baseline-shift',\n    bbox: 0,\n    begin: 0,\n    bias: 0,\n    by: 0,\n    calcMode: 'calcMode',\n    capHeight: 'cap-height',\n    clip: 0,\n    clipPath: 'clip-path',\n    clipRule: 'clip-rule',\n    clipPathUnits: 'clipPathUnits',\n    colorInterpolation: 'color-interpolation',\n    colorInterpolationFilters: 'color-interpolation-filters',\n    colorProfile: 'color-profile',\n    colorRendering: 'color-rendering',\n    contentScriptType: 'contentScriptType',\n    contentStyleType: 'contentStyleType',\n    cursor: 0,\n    cx: 0,\n    cy: 0,\n    d: 0,\n    decelerate: 0,\n    descent: 0,\n    diffuseConstant: 'diffuseConstant',\n    direction: 0,\n    display: 0,\n    divisor: 0,\n    dominantBaseline: 'dominant-baseline',\n    dur: 0,\n    dx: 0,\n    dy: 0,\n    edgeMode: 'edgeMode',\n    elevation: 0,\n    enableBackground: 'enable-background',\n    end: 0,\n    evEvent: 'ev:event',\n    exponent: 0,\n    externalResourcesRequired: 'externalResourcesRequired',\n    fill: 0,\n    fillOpacity: 'fill-opacity',\n    fillRule: 'fill-rule',\n    filter: 0,\n    filterRes: 'filterRes',\n    filterUnits: 'filterUnits',\n    floodColor: 'flood-color',\n    floodOpacity: 'flood-opacity',\n    focusable: 0,\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    fontSizeAdjust: 'font-size-adjust',\n    fontStretch: 'font-stretch',\n    fontStyle: 'font-style',\n    fontVariant: 'font-variant',\n    fontWeight: 'font-weight',\n    format: 0,\n    from: 0,\n    fx: 0,\n    fy: 0,\n    g1: 0,\n    g2: 0,\n    glyphName: 'glyph-name',\n    glyphOrientationHorizontal: 'glyph-orientation-horizontal',\n    glyphOrientationVertical: 'glyph-orientation-vertical',\n    glyphRef: 'glyphRef',\n    gradientTransform: 'gradientTransform',\n    gradientUnits: 'gradientUnits',\n    hanging: 0,\n    horizAdvX: 'horiz-adv-x',\n    horizOriginX: 'horiz-origin-x',\n    ideographic: 0,\n    imageRendering: 'image-rendering',\n    'in': 0,\n    in2: 0,\n    intercept: 0,\n    k: 0,\n    k1: 0,\n    k2: 0,\n    k3: 0,\n    k4: 0,\n    kernelMatrix: 'kernelMatrix',\n    kernelUnitLength: 'kernelUnitLength',\n    kerning: 0,\n    keyPoints: 'keyPoints',\n    keySplines: 'keySplines',\n    keyTimes: 'keyTimes',\n    lengthAdjust: 'lengthAdjust',\n    letterSpacing: 'letter-spacing',\n    lightingColor: 'lighting-color',\n    limitingConeAngle: 'limitingConeAngle',\n    local: 0,\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    markerHeight: 'markerHeight',\n    markerUnits: 'markerUnits',\n    markerWidth: 'markerWidth',\n    mask: 0,\n    maskContentUnits: 'maskContentUnits',\n    maskUnits: 'maskUnits',\n    mathematical: 0,\n    mode: 0,\n    numOctaves: 'numOctaves',\n    offset: 0,\n    opacity: 0,\n    operator: 0,\n    order: 0,\n    orient: 0,\n    orientation: 0,\n    origin: 0,\n    overflow: 0,\n    overlinePosition: 'overline-position',\n    overlineThickness: 'overline-thickness',\n    paintOrder: 'paint-order',\n    panose1: 'panose-1',\n    pathLength: 'pathLength',\n    patternContentUnits: 'patternContentUnits',\n    patternTransform: 'patternTransform',\n    patternUnits: 'patternUnits',\n    pointerEvents: 'pointer-events',\n    points: 0,\n    pointsAtX: 'pointsAtX',\n    pointsAtY: 'pointsAtY',\n    pointsAtZ: 'pointsAtZ',\n    preserveAlpha: 'preserveAlpha',\n    preserveAspectRatio: 'preserveAspectRatio',\n    primitiveUnits: 'primitiveUnits',\n    r: 0,\n    radius: 0,\n    refX: 'refX',\n    refY: 'refY',\n    renderingIntent: 'rendering-intent',\n    repeatCount: 'repeatCount',\n    repeatDur: 'repeatDur',\n    requiredExtensions: 'requiredExtensions',\n    requiredFeatures: 'requiredFeatures',\n    restart: 0,\n    result: 0,\n    rotate: 0,\n    rx: 0,\n    ry: 0,\n    scale: 0,\n    seed: 0,\n    shapeRendering: 'shape-rendering',\n    slope: 0,\n    spacing: 0,\n    specularConstant: 'specularConstant',\n    specularExponent: 'specularExponent',\n    speed: 0,\n    spreadMethod: 'spreadMethod',\n    startOffset: 'startOffset',\n    stdDeviation: 'stdDeviation',\n    stemh: 0,\n    stemv: 0,\n    stitchTiles: 'stitchTiles',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strikethroughPosition: 'strikethrough-position',\n    strikethroughThickness: 'strikethrough-thickness',\n    string: 0,\n    stroke: 0,\n    strokeDasharray: 'stroke-dasharray',\n    strokeDashoffset: 'stroke-dashoffset',\n    strokeLinecap: 'stroke-linecap',\n    strokeLinejoin: 'stroke-linejoin',\n    strokeMiterlimit: 'stroke-miterlimit',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    surfaceScale: 'surfaceScale',\n    systemLanguage: 'systemLanguage',\n    tableValues: 'tableValues',\n    targetX: 'targetX',\n    targetY: 'targetY',\n    textAnchor: 'text-anchor',\n    textDecoration: 'text-decoration',\n    textRendering: 'text-rendering',\n    textLength: 'textLength',\n    to: 0,\n    transform: 0,\n    u1: 0,\n    u2: 0,\n    underlinePosition: 'underline-position',\n    underlineThickness: 'underline-thickness',\n    unicode: 0,\n    unicodeBidi: 'unicode-bidi',\n    unicodeRange: 'unicode-range',\n    unitsPerEm: 'units-per-em',\n    vAlphabetic: 'v-alphabetic',\n    vHanging: 'v-hanging',\n    vIdeographic: 'v-ideographic',\n    vMathematical: 'v-mathematical',\n    values: 0,\n    vectorEffect: 'vector-effect',\n    version: 0,\n    vertAdvY: 'vert-adv-y',\n    vertOriginX: 'vert-origin-x',\n    vertOriginY: 'vert-origin-y',\n    viewBox: 'viewBox',\n    viewTarget: 'viewTarget',\n    visibility: 0,\n    widths: 0,\n    wordSpacing: 'word-spacing',\n    writingMode: 'writing-mode',\n    x: 0,\n    xHeight: 'x-height',\n    x1: 0,\n    x2: 0,\n    xChannelSelector: 'xChannelSelector',\n    xlinkActuate: 'xlink:actuate',\n    xlinkArcrole: 'xlink:arcrole',\n    xlinkHref: 'xlink:href',\n    xlinkRole: 'xlink:role',\n    xlinkShow: 'xlink:show',\n    xlinkTitle: 'xlink:title',\n    xlinkType: 'xlink:type',\n    xmlBase: 'xml:base',\n    xmlId: 'xml:id',\n    xmlns: 0,\n    xmlnsXlink: 'xmlns:xlink',\n    xmlLang: 'xml:lang',\n    xmlSpace: 'xml:space',\n    y: 0,\n    y1: 0,\n    y2: 0,\n    yChannelSelector: 'yChannelSelector',\n    z: 0,\n    zoomAndPan: 'zoomAndPan'\n};\nvar SVGPropertyConfig = {\n    Properties: {},\n    DOMAttributeNamespaces: {\n        'ev:event': NS.ev,\n        'xlink:actuate': NS.xlink,\n        'xlink:arcrole': NS.xlink,\n        'xlink:href': NS.xlink,\n        'xlink:role': NS.xlink,\n        'xlink:show': NS.xlink,\n        'xlink:title': NS.xlink,\n        'xlink:type': NS.xlink,\n        'xml:base': NS.xml,\n        'xml:id': NS.xml,\n        'xml:lang': NS.xml,\n        'xml:space': NS.xml\n    },\n    DOMAttributeNames: {}\n};\nObject.keys(ATTRS).forEach(function (key) {\n    SVGPropertyConfig.Properties[key] = 0;\n    if (ATTRS[key]) {\n        SVGPropertyConfig.DOMAttributeNames[key] = ATTRS[key];\n    }\n});\n\n/* tslint:disable: no-empty*/\nfunction patch(lastVnode, nextVnode, parentNode, context, isSvg) {\n    var lastDom = lastVnode.dom;\n    var newDom;\n    var lastVnodeIsArray = isArray(lastVnode);\n    var nextVnodeisArray = isArray(nextVnode);\n    if (isSameVNode(lastVnode, nextVnode)) {\n        var vtype = nextVnode.vtype;\n        if (vtype & 2 /* Node */) {\n                isSvg = isNullOrUndef(isSvg) ? lastVnode.isSvg : isSvg;\n                if (isSvg) {\n                    nextVnode.isSvg = isSvg;\n                }\n                patchProps(lastDom, nextVnode.props, lastVnode.props, lastVnode, isSvg);\n                patchChildren(lastDom, lastVnode.children, nextVnode.children, context, isSvg);\n                if (nextVnode.ref !== null) {\n                    Ref.update(lastVnode, nextVnode, lastDom);\n                }\n                newDom = lastDom;\n            } else if ((vtype & 4 /* Composite */) > 0) {\n            newDom = nextVnode.update(lastVnode, nextVnode, context);\n        } else if (vtype & 1 /* Text */) {\n                return patchVText(lastVnode, nextVnode);\n            } else if (vtype & 32 /* Portal */) {\n                patchChildren(lastVnode.type, lastVnode.children, nextVnode.children, context, isSvg);\n            }\n        // @TODO: test case\n        nextVnode.dom = newDom || lastDom;\n    } else if (isArray(lastVnode) && isArray(nextVnode)) {\n        patchArrayChildren(lastDom, lastVnode, nextVnode, context, false);\n    } else if (lastVnodeIsArray && !nextVnodeisArray) {\n        patchArrayChildren(parentNode, lastVnode, [nextVnode], context, false);\n    } else if (!lastVnodeIsArray && nextVnodeisArray) {\n        newDom = createElement(nextVnode, isSvg, context);\n        insertElement(newDom, parentNode, lastDom);\n        parentNode.removeChild(lastDom);\n    } else {\n        unmount(lastVnode);\n        newDom = createElement(nextVnode, isSvg, context);\n        if (nextVnode !== null) {\n            nextVnode.dom = newDom;\n        }\n        var newDomIsArray = isArray(newDom);\n        var lastDomIsArray = isArray(lastDom);\n        if (newDomIsArray) {\n            insertElement(newDom, parentNode, lastDom);\n            parentNode.removeChild(lastDom);\n        } else if (lastDomIsArray) {\n            parentNode = lastDom[0].parentNode;\n            parentNode.insertBefore(newDom, lastDom[0]);\n            for (var i = 0; i < lastDom.length; i++) {\n                parentNode.removeChild(lastDom[i]);\n            }\n        } else if (parentNode !== null) {\n            parentNode.replaceChild(newDom, lastDom);\n        }\n    }\n    return newDom;\n}\nfunction patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg) {\n    var lastLength = lastChildren.length;\n    var nextLength = nextChildren.length;\n    if (lastLength === 0) {\n        if (nextLength > 0) {\n            for (var i = 0; i < nextLength; i++) {\n                mountChild(nextChildren[i], parentDom, context, isSvg);\n            }\n        }\n    } else if (nextLength === 0) {\n        unmountChildren(lastChildren);\n        parentDom.textContent = '';\n    } else {\n        if (isKeyed(lastChildren, nextChildren)) {\n            patchKeyedChildren(lastChildren, nextChildren, parentDom, context, isSvg, lastLength, nextLength);\n        } else {\n            patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength);\n        }\n    }\n}\nfunction patchChildren(parentDom, lastChildren, nextChildren, context, isSvg) {\n    // @TODO: is a better way to compatible with react-router?\n    // if (lastChildren === nextChildren) {\n    //   return\n    // }\n    var lastChildrenIsArray = isArray(lastChildren);\n    var nextChildrenIsArray = isArray(nextChildren);\n    if (lastChildrenIsArray && nextChildrenIsArray) {\n        patchArrayChildren(parentDom, lastChildren, nextChildren, context, isSvg);\n    } else if (!lastChildrenIsArray && !nextChildrenIsArray) {\n        patch(lastChildren, nextChildren, parentDom, context, isSvg);\n    } else if (lastChildrenIsArray && !nextChildrenIsArray) {\n        patchArrayChildren(parentDom, lastChildren, [nextChildren], context, isSvg);\n    } else if (!lastChildrenIsArray && nextChildrenIsArray) {\n        patchArrayChildren(parentDom, [lastChildren], nextChildren, context, isSvg);\n    }\n}\nfunction patchNonKeyedChildren(parentDom, lastChildren, nextChildren, context, isSvg, lastLength, nextLength) {\n    var minLength = Math.min(lastLength, nextLength);\n    var i = 0;\n    while (i < minLength) {\n        patch(lastChildren[i], nextChildren[i], parentDom, context, isSvg);\n        i++;\n    }\n    if (lastLength < nextLength) {\n        for (i = minLength; i < nextLength; i++) {\n            if (parentDom !== null) {\n                var refVnode = lastChildren[i - 1];\n                mountElement(createElement(nextChildren[i], isSvg, context), parentDom, isValidElement(refVnode) && refVnode.dom != null ? refVnode.dom.nextSibling : null);\n            }\n        }\n    } else if (lastLength > nextLength) {\n        for (i = minLength; i < lastLength; i++) {\n            unmount(lastChildren[i], parentDom);\n        }\n    }\n}\n/**\r\n *\r\n * Virtual DOM patching algorithm based on ivi by\r\n * Boris Kaul (@localvoid)\r\n * Licensed under the MIT License\r\n * https://github.com/ivijs/ivi/blob/master/LICENSE\r\n *\r\n */\nfunction patchKeyedChildren(a, b, dom, context, isSvg, aLength, bLength) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var aStart = 0;\n    var bStart = 0;\n    var i;\n    var j;\n    var aNode;\n    var bNode;\n    var nextNode;\n    var nextPos;\n    var node;\n    var aStartNode = a[aStart];\n    var bStartNode = b[bStart];\n    var aEndNode = a[aEnd];\n    var bEndNode = b[bEnd];\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode.key === bStartNode.key) {\n            patch(aStartNode, bStartNode, dom, context, isSvg);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n        }\n        // Sync nodes with the same key at the end.\n        while (aEndNode.key === bEndNode.key) {\n            patch(aEndNode, bEndNode, dom, context, isSvg);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n        }\n    }\n    if (aStart > aEnd) {\n        if (bStart <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? b[nextPos].dom : null;\n            while (bStart <= bEnd) {\n                node = b[bStart];\n                bStart++;\n                attachNewNode(dom, createElement(node, isSvg, context), nextNode);\n            }\n        }\n    } else if (bStart > bEnd) {\n        while (aStart <= aEnd) {\n            unmount(a[aStart++], dom);\n        }\n    } else {\n        var aLeft = aEnd - aStart + 1;\n        var bLeft = bEnd - bStart + 1;\n        var sources = new Array(bLeft);\n        // Mark all nodes as inserted.\n        for (i = 0; i < bLeft; i++) {\n            sources[i] = -1;\n        }\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        // When sizes are small, just loop them through\n        if (bLeft <= 4 || aLeft * bLeft <= 16) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i;\n                            if (pos > j) {\n                                moved = true;\n                            } else {\n                                pos = j;\n                            }\n                            patch(aNode, bNode, dom, context, isSvg);\n                            patched++;\n                            a[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            var keyIndex = new MapClass();\n            for (i = bStart; i <= bEnd; i++) {\n                keyIndex.set(b[i].key, i);\n            }\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLeft) {\n                    j = keyIndex.get(aNode.key);\n                    if (j !== undefined) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        } else {\n                            pos = j;\n                        }\n                        patch(aNode, bNode, dom, context, isSvg);\n                        patched++;\n                        a[i] = null;\n                    }\n                }\n            }\n        }\n        if (aLeft === aLength && patched === 0) {\n            unmountChildren(a);\n            dom.textContent = '';\n            while (bStart < bLeft) {\n                node = b[bStart];\n                bStart++;\n                attachNewNode(dom, createElement(node, isSvg, context), null);\n            }\n        } else {\n            i = aLeft - patched;\n            while (i > 0) {\n                aNode = a[aStart++];\n                if (aNode !== null) {\n                    unmount(aNode, dom);\n                    i--;\n                }\n            }\n            if (moved) {\n                var seq = lis(sources);\n                j = seq.length - 1;\n                for (i = bLeft - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        attachNewNode(dom, createElement(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);\n                    } else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            attachNewNode(dom, node.dom, nextPos < bLength ? b[nextPos].dom : null);\n                        } else {\n                            j--;\n                        }\n                    }\n                }\n            } else if (patched !== bLeft) {\n                for (i = bLeft - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        attachNewNode(dom, createElement(node, isSvg, context), nextPos < bLength ? b[nextPos].dom : null);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction attachNewNode(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        parentDom.appendChild(newNode);\n    } else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\n/**\r\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\r\n * new items.\r\n *\r\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\n *\r\n * @param a Array of numbers.\r\n * @returns Longest increasing subsequence.\r\n */\nfunction lis(a) {\n    var p = a.slice();\n    var result = [];\n    result.push(0);\n    var u;\n    var v;\n    for (var i = 0, il = a.length; i < il; ++i) {\n        if (a[i] === -1) {\n            continue;\n        }\n        var j = result[result.length - 1];\n        if (a[j] < a[i]) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n        u = 0;\n        v = result.length - 1;\n        while (u < v) {\n            var c = (u + v) / 2 | 0;\n            if (a[result[c]] < a[i]) {\n                u = c + 1;\n            } else {\n                v = c;\n            }\n        }\n        if (a[i] < a[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\nfunction isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length > 0 && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key) && lastChildren.length > 0 && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}\nfunction isSameVNode(a, b) {\n    if (isInvalid(a) || isInvalid(b) || isArray(a) || isArray(b)) {\n        return false;\n    }\n    return a.type === b.type && a.vtype === b.vtype && a.key === b.key;\n}\nfunction patchVText(lastVNode, nextVNode) {\n    var dom = lastVNode.dom;\n    if (dom === null) {\n        return;\n    }\n    var nextText = nextVNode.text;\n    nextVNode.dom = dom;\n    if (lastVNode.text !== nextText) {\n        dom.nodeValue = nextText;\n    }\n    return dom;\n}\nvar skipProps = {\n    children: 1,\n    key: 1,\n    ref: 1,\n    owner: 1\n};\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\nfunction setStyle(domStyle, style, value) {\n    if (isNullOrUndef(value) || isNumber(value) && isNaN(value)) {\n        domStyle[style] = '';\n        return;\n    }\n    if (style === 'float') {\n        domStyle['cssFloat'] = value;\n        domStyle['styleFloat'] = value;\n        return;\n    }\n    domStyle[style] = !isNumber(value) || IS_NON_DIMENSIONAL.test(style) ? value : value + 'px';\n}\nfunction patchEvent(eventName, lastEvent, nextEvent, domNode) {\n    if (lastEvent !== nextEvent) {\n        if (isFunction(lastEvent)) {\n            detachEvent(domNode, eventName, lastEvent);\n        }\n        attachEvent(domNode, eventName, nextEvent);\n    }\n}\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                setStyle(domStyle, style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle[style] = '';\n            }\n        }\n    } else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            setStyle(domStyle, style, value);\n        }\n    }\n}\nfunction patchProp(domNode, prop, lastValue, nextValue, lastVnode, isSvg) {\n    // fix the value update for textarea/input\n    if (lastValue !== nextValue || prop === 'value') {\n        if (prop === 'className') {\n            prop = 'class';\n        }\n        if (skipProps[prop] === 1) {\n            return;\n        } else if (prop === 'class' && !isSvg) {\n            domNode.className = nextValue;\n        } else if (prop === 'dangerouslySetInnerHTML') {\n            var lastHtml = lastValue && lastValue.__html;\n            var nextHtml = nextValue && nextValue.__html;\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml)) {\n                    if (isValidElement(lastVnode) && lastVnode.children !== EMPTY_CHILDREN) {\n                        unmountChildren(lastVnode.children);\n                        lastVnode.children = [];\n                    }\n                    domNode.innerHTML = nextHtml;\n                }\n            }\n        } else if (isAttrAnEvent(prop)) {\n            patchEvent(prop, lastValue, nextValue, domNode);\n        } else if (prop === 'style') {\n            patchStyle(lastValue, nextValue, domNode);\n        } else if (prop !== 'list' && prop !== 'type' && !isSvg && prop in domNode) {\n            setProperty(domNode, prop, nextValue == null ? '' : nextValue);\n            if (nextValue == null || nextValue === false) {\n                domNode.removeAttribute(prop);\n            }\n        } else if (isNullOrUndef(nextValue) || nextValue === false) {\n            domNode.removeAttribute(prop);\n        } else {\n            var namespace = SVGPropertyConfig.DOMAttributeNamespaces[prop];\n            if (isSvg && namespace) {\n                if (nextValue) {\n                    domNode.setAttributeNS(namespace, prop, nextValue);\n                } else {\n                    var colonPosition = prop.indexOf(':');\n                    var localName = colonPosition > -1 ? prop.substr(colonPosition + 1) : prop;\n                    domNode.removeAttributeNS(namespace, localName);\n                }\n            } else {\n                if (!isFunction(nextValue)) {\n                    domNode.setAttribute(prop, nextValue);\n                }\n                // WARNING: Non-event attributes with function values:\n                // https://reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html#changes-in-detail\n            }\n        }\n    }\n}\nfunction setProperty(node, name, value) {\n    try {\n        node[name] = value;\n    } catch (e) {}\n}\nfunction patchProps(domNode, nextProps, previousProps, lastVnode, isSvg) {\n    for (var propName in previousProps) {\n        var value = previousProps[propName];\n        if (isNullOrUndef(nextProps[propName]) && !isNullOrUndef(value)) {\n            if (isAttrAnEvent(propName)) {\n                detachEvent(domNode, propName, value);\n            } else if (propName === 'dangerouslySetInnerHTML') {\n                domNode.textContent = '';\n            } else if (propName === 'className') {\n                domNode.removeAttribute('class');\n            } else {\n                domNode.removeAttribute(propName);\n            }\n        }\n    }\n    for (var propName$1 in nextProps) {\n        patchProp(domNode, propName$1, previousProps[propName$1], nextProps[propName$1], lastVnode, isSvg);\n    }\n}\n\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nfunction createElement(vnode, isSvg, parentContext, parentComponent) {\n    var domNode;\n    if (isValidElement(vnode)) {\n        var vtype = vnode.vtype;\n        if (vtype & 4 /* Composite */) {\n            domNode = vnode.init(parentContext, parentComponent);\n        } else if (vtype & 1 /* Text */) {\n                domNode = doc.createTextNode(vnode.text);\n                vnode.dom = domNode;\n            } else if (vtype & 2 /* Node */) {\n                domNode = mountVNode$1(vnode, isSvg, parentContext, parentComponent);\n            } else if (vtype & 16 /* Void */) {\n                domNode = vnode.dom = doc.createTextNode('');\n            } else if (isPortal(vtype, vnode)) {\n            vnode.type.appendChild(createElement(vnode.children, isSvg, parentContext, parentComponent));\n            domNode = doc.createTextNode('');\n        }\n    } else if (isString(vnode) || isNumber(vnode)) {\n        domNode = doc.createTextNode(vnode);\n    } else if (isNullOrUndef(vnode) || isBoolean(vnode)) {\n        domNode = doc.createTextNode('');\n    } else if (isArray(vnode)) {\n        domNode = vnode.map(function (child) {\n            return createElement(child, isSvg, parentContext, parentComponent);\n        });\n    } else {\n        throw new Error('Unsupported VNode.');\n    }\n    return domNode;\n}\nfunction mountVNode$1(vnode, isSvg, parentContext, parentComponent) {\n    if (vnode.isSvg) {\n        isSvg = true;\n    } else if (vnode.type === 'svg') {\n        isSvg = true;\n        /* istanbul ignore next */\n    } else if (!isSupportSVG) {\n        isSvg = false;\n    }\n    if (isSvg) {\n        vnode.namespace = SVG_NAMESPACE;\n        vnode.isSvg = isSvg;\n    }\n    var domNode = !isSvg ? doc.createElement(vnode.type) : doc.createElementNS(vnode.namespace, vnode.type);\n    setProps(domNode, vnode, isSvg);\n    if (vnode.type === 'foreignObject') {\n        isSvg = false;\n    }\n    var children = vnode.children;\n    if (isArray(children)) {\n        for (var i = 0, len = children.length; i < len; i++) {\n            mountChild(children[i], domNode, parentContext, isSvg, parentComponent);\n        }\n    } else {\n        mountChild(children, domNode, parentContext, isSvg, parentComponent);\n    }\n    vnode.dom = domNode;\n    if (vnode.ref !== null) {\n        Ref.attach(vnode, vnode.ref, domNode);\n    }\n    return domNode;\n}\nfunction mountChild(child, domNode, parentContext, isSvg, parentComponent) {\n    child.parentContext = parentContext || EMPTY_OBJ;\n    var childNode = createElement(child, isSvg, parentContext, parentComponent);\n    mountElement(childNode, domNode);\n}\nfunction mountElement(element, parentNode, refChild) {\n    if (isArray(element)) {\n        for (var i = 0; i < element.length; i++) {\n            var el = element[i];\n            mountElement(el, parentNode);\n        }\n    } else {\n        refChild != null ? parentNode.insertBefore(element, refChild) : parentNode.appendChild(element);\n    }\n}\nfunction insertElement(element, parentNode, lastDom) {\n    if (isArray(element)) {\n        for (var i = 0; i < element.length; i++) {\n            var el = element[i];\n            insertElement(el, parentNode, lastDom);\n        }\n    } else {\n        parentNode.insertBefore(element, lastDom);\n    }\n}\nfunction setProps(domNode, vnode, isSvg) {\n    var props = vnode.props;\n    for (var p in props) {\n        patchProp(domNode, p, null, props[p], null, isSvg);\n    }\n}\n\nfunction createVText(text) {\n    return {\n        text: text,\n        vtype: 1 /* Text */\n        , dom: null\n    };\n}\n\nfunction createVoid() {\n    return {\n        dom: null,\n        vtype: 16 /* Void */\n    };\n}\n\nfunction getHooks(index) {\n    if (Current.current === null) {\n        throw new Error(\"invalid hooks call: hooks can only be called in a stateless component.\");\n    }\n    var hooks = Current.current.hooks;\n    if (index >= hooks.length) {\n        hooks.push({});\n    }\n    return hooks[index];\n}\nfunction useState(initialState) {\n    if (isFunction(initialState)) {\n        initialState = initialState();\n    }\n    var hook = getHooks(Current.index++);\n    if (!hook.state) {\n        hook.component = Current.current;\n        hook.state = [initialState, function (action) {\n            hook.state[0] = isFunction(action) ? action(hook.state[0]) : action;\n            hook.component._disable = false;\n            hook.component.setState({});\n        }];\n    }\n    return hook.state;\n}\nfunction useReducer(reducer, initialState, initializer) {\n    if (isFunction(initialState)) {\n        initialState = initialState();\n    }\n    var hook = getHooks(Current.index++);\n    if (!hook.state) {\n        hook.component = Current.current;\n        hook.state = [isUndefined(initializer) ? initialState : initializer(initialState), function (action) {\n            hook.state[0] = reducer(hook.state[0], action);\n            hook.component._disable = false;\n            hook.component.setState({});\n        }];\n    }\n    return hook.state;\n}\nfunction areDepsChanged(prevDeps, deps) {\n    if (isNullOrUndef(prevDeps) || isNullOrUndef(deps)) {\n        return true;\n    }\n    return deps.some(function (d, i) {\n        return !objectIs(d, prevDeps[i]);\n    });\n}\nfunction invokeEffects(component, delay) {\n    if (delay === void 0) delay = false;\n\n    var effects = delay ? component.effects : component.layoutEffects;\n    effects.forEach(function (hook) {\n        if (isFunction(hook.cleanup)) {\n            hook.cleanup();\n        }\n        var result = hook.effect();\n        if (isFunction(result)) {\n            hook.cleanup = result;\n        }\n    });\n    if (delay) {\n        component.effects = [];\n    } else {\n        component.layoutEffects = [];\n    }\n}\nvar scheduleEffectComponents = [];\nfunction invokeScheduleEffects(component) {\n    if (!component._afterScheduleEffect) {\n        component._afterScheduleEffect = true;\n        scheduleEffectComponents.push(component);\n        if (scheduleEffectComponents.length === 1) {\n            nextTick(function () {\n                setTimeout(function () {\n                    scheduleEffectComponents.forEach(function (c) {\n                        c._afterScheduleEffect = false;\n                        invokeEffects(c, true);\n                    });\n                    scheduleEffectComponents = [];\n                }, 0);\n            });\n        }\n    }\n}\nfunction useEffectImpl(effect, deps, delay) {\n    if (delay === void 0) delay = false;\n\n    var hook = getHooks(Current.index++);\n    if (areDepsChanged(hook.deps, deps)) {\n        hook.effect = effect;\n        hook.deps = deps;\n        if (delay) {\n            Current.current.effects = Current.current.effects.concat(hook);\n            invokeScheduleEffects(Current.current);\n        } else {\n            Current.current.layoutEffects = Current.current.layoutEffects.concat(hook);\n        }\n    }\n}\nfunction useEffect(effect, deps) {\n    useEffectImpl(effect, deps, true);\n}\nfunction useLayoutEffect(effect, deps) {\n    useEffectImpl(effect, deps);\n}\nfunction useRef(initialValue) {\n    var hook = getHooks(Current.index++);\n    if (!hook.ref) {\n        hook.ref = {\n            current: initialValue\n        };\n    }\n    return hook.ref;\n}\nfunction useMemo(factory, deps) {\n    var hook = getHooks(Current.index++);\n    if (areDepsChanged(hook.deps, deps)) {\n        hook.deps = deps;\n        hook.callback = factory;\n        hook.value = factory();\n    }\n    return hook.value;\n}\nfunction useCallback(callback, deps) {\n    return useMemo(function () {\n        return callback;\n    }, deps);\n}\nfunction useContext(context) {\n    var provider = Current.current.context[context._id];\n    if (isUndefined(provider)) {\n        return context._defaultValue;\n    }\n    var hook = getHooks(Current.index++);\n    // should update when value changes with shouldComponentUpdate:false Component on top\n    if (isUndefined(hook.context)) {\n        hook.context = true;\n        var c = Current.current;\n        provider.on(function () {\n            return enqueueRender(c);\n        });\n    }\n    return provider.value;\n}\nfunction useImperativeHandle(ref, init, deps) {\n    useLayoutEffect(function () {\n        if (isFunction(ref)) {\n            ref(init());\n            return function () {\n                return ref(null);\n            };\n        } else if (!isUndefined(ref)) {\n            ref.current = init();\n            return function () {\n                delete ref.current;\n            };\n        }\n    }, isArray(deps) ? deps.concat([ref]) : undefined);\n}\n\n// import { extend, isFunction, isNumber, isString } from 'nerv-utils'\nvar readyComponents = [];\nfunction errorCatcher(fn, component) {\n    try {\n        return fn();\n    } catch (error) {\n        errorHandler(component, error);\n    }\n}\nfunction errorHandler(component, error) {\n    // if(!component) { throw error ; return }\n    var boundary;\n    while (true) {\n        var ref = component.constructor;\n        var getDerivedStateFromError = ref.getDerivedStateFromError;\n        if (isFunction(getDerivedStateFromError) || isFunction(component.componentDidCatch)) {\n            boundary = component;\n            break;\n        } else if (component._parentComponent) {\n            component = component._parentComponent;\n        } else {\n            break;\n        }\n    }\n    if (boundary) {\n        var ref$1 = boundary.constructor;\n        var getDerivedStateFromError$1 = ref$1.getDerivedStateFromError;\n        var _disable = boundary._disable;\n        boundary._disable = false;\n        if (isFunction(getDerivedStateFromError$1)) {\n            component.setState(getDerivedStateFromError$1(error));\n        } else if (isFunction(component.componentDidCatch)) {\n            boundary.componentDidCatch(error);\n        }\n        boundary._disable = _disable;\n    } else {\n        throw error;\n    }\n}\nfunction ensureVirtualNode(rendered) {\n    if (isNumber(rendered) || isString(rendered)) {\n        return createVText(rendered);\n    } else if (isInvalid(rendered)) {\n        return createVoid();\n    } else if (isArray(rendered)) {\n        rendered = rendered.length === 0 ? createVoid() : rendered.map(ensureVirtualNode);\n    }\n    return rendered;\n}\nfunction mountVNode(vnode, parentContext, parentComponent) {\n    return createElement(vnode, false, parentContext, parentComponent);\n}\nfunction getContextByContextType(vnode, parentContext) {\n    var contextType = vnode.type.contextType;\n    var hasContextType = !isUndefined(contextType);\n    var provider = hasContextType ? parentContext[contextType._id] : null;\n    var context = hasContextType ? !isNullOrUndef(provider) ? provider.value : contextType._defaultValue : parentContext;\n    return context;\n}\nfunction mountComponent(vnode, parentContext, parentComponent) {\n    var ref = vnode.ref;\n    if (vnode.type.prototype && vnode.type.prototype.render) {\n        var context = getContextByContextType(vnode, parentContext);\n        vnode.component = new vnode.type(vnode.props, context);\n    } else {\n        var c = new Component(vnode.props, parentContext);\n        c.render = function () {\n            return vnode.type.call(c, c.props, c.context);\n        };\n        vnode.component = c;\n    }\n    var component = vnode.component;\n    component.vnode = vnode;\n    if (isComponent(parentComponent)) {\n        component._parentComponent = parentComponent;\n    }\n    var newState = callGetDerivedStateFromProps(vnode.props, component.state, component);\n    if (!isUndefined(newState)) {\n        component.state = newState;\n    }\n    if (!hasNewLifecycle(component) && isFunction(component.componentWillMount)) {\n        errorCatcher(function () {\n            component.componentWillMount();\n        }, component);\n        component.state = component.getState();\n        component.clearCallBacks();\n    }\n    component._dirty = false;\n    var rendered = renderComponent(component);\n    rendered.parentVNode = vnode;\n    component._rendered = rendered;\n    if (!isNullOrUndef(ref)) {\n        Ref.attach(vnode, ref, vnode.dom);\n    }\n    var dom = vnode.dom = mountVNode(rendered, getChildContext(component, parentContext), component);\n    invokeEffects(component);\n    if (isFunction(component.componentDidMount)) {\n        readyComponents.push(component);\n    }\n    component._disable = false;\n    return dom;\n}\nfunction getChildContext(component, context) {\n    if (context === void 0) context = EMPTY_OBJ;\n\n    if (isFunction(component.getChildContext)) {\n        return extend(clone(context), component.getChildContext());\n    }\n    return clone(context);\n}\nfunction renderComponent(component) {\n    Current.current = component;\n    Current.index = 0;\n    invokeEffects(component, true);\n    var rendered;\n    errorCatcher(function () {\n        rendered = component.render();\n    }, component);\n    rendered = ensureVirtualNode(rendered);\n    Current.current = null;\n    return rendered;\n}\nfunction flushMount() {\n    if (!readyComponents.length) {\n        return;\n    }\n    // @TODO: perf\n    var queue = readyComponents.slice(0);\n    readyComponents.length = 0;\n    queue.forEach(function (item) {\n        if (isFunction(item)) {\n            item();\n        } else if (item.componentDidMount) {\n            errorCatcher(function () {\n                item.componentDidMount();\n            }, item);\n        }\n    });\n}\nfunction getFragmentHostNode(children) {\n    var child = children[0];\n    if (isArray(child)) {\n        return getFragmentHostNode(child);\n    } else if (isComposite(child) && child.dom == null) {\n        return getFragmentHostNode(child.component._rendered);\n    }\n    return child.dom;\n}\nfunction reRenderComponent(prev, current) {\n    var component = current.component = prev.component;\n    var nextProps = current.props;\n    var nextContext = current.context;\n    component._disable = true;\n    if (!hasNewLifecycle(component) && isFunction(component.componentWillReceiveProps)) {\n        errorCatcher(function () {\n            component.componentWillReceiveProps(nextProps, nextContext);\n        }, component);\n    }\n    component._disable = false;\n    component.prevProps = component.props;\n    component.prevState = component.state;\n    component.prevContext = component.context;\n    component.props = nextProps;\n    component.context = nextContext;\n    if (!isNullOrUndef(current.ref)) {\n        Ref.update(prev, current);\n    }\n    return updateComponent(component);\n}\nfunction callShouldComponentUpdate(props, state, context, component) {\n    var shouldUpdate = true;\n    errorCatcher(function () {\n        shouldUpdate = component.shouldComponentUpdate(props, state, context);\n    }, component);\n    return shouldUpdate;\n}\nfunction updateComponent(component, isForce) {\n    if (isForce === void 0) isForce = false;\n\n    var vnode = component.vnode;\n    var dom = vnode.dom;\n    var props = component.props;\n    var state = component.getState();\n    var context = component.context;\n    var prevProps = component.prevProps || props;\n    var prevState = component.prevState || component.state;\n    var prevContext = component.prevContext || context;\n    var stateFromProps = callGetDerivedStateFromProps(props, state, component);\n    if (!isUndefined(stateFromProps)) {\n        state = stateFromProps;\n    }\n    component.props = prevProps;\n    component.context = prevContext;\n    var skip = false;\n    var onSCU = props.onShouldComponentUpdate;\n    if (!isForce && (isFunction(component.shouldComponentUpdate) && callShouldComponentUpdate(props, state, context, component) === false || isFunction(onSCU) && onSCU(prevProps, props) === false)) {\n        skip = true;\n    } else if (!hasNewLifecycle(component) && isFunction(component.componentWillUpdate)) {\n        errorCatcher(function () {\n            component.componentWillUpdate(props, state, context);\n        }, component);\n    }\n    if (!isUndefined(stateFromProps)) {\n        component.state = stateFromProps;\n    }\n    component.props = props;\n    component.state = state;\n    component.context = context;\n    component._dirty = false;\n    if (!skip) {\n        var lastRendered = component._rendered;\n        var rendered = renderComponent(component);\n        rendered.parentVNode = vnode;\n        var childContext = getChildContext(component, context);\n        var snapshot = callGetSnapshotBeforeUpdate(prevProps, prevState, component);\n        var parentDom = lastRendered.dom && lastRendered.dom.parentNode;\n        if (isArray(lastRendered)) {\n            var hostNode = getFragmentHostNode(lastRendered);\n            if (hostNode) {\n                parentDom = lastRendered.dom = hostNode.parentNode;\n            }\n        }\n        dom = vnode.dom = patch(lastRendered, rendered, parentDom || null, childContext);\n        component._rendered = rendered;\n        if (isFunction(component.componentDidUpdate)) {\n            errorCatcher(function () {\n                component.componentDidUpdate(prevProps, prevState, snapshot);\n            }, component);\n        }\n        while (vnode = vnode.parentVNode) {\n            if ((vnode.vtype & 4 /* Composite */) > 0) {\n                vnode.dom = dom;\n            }\n        }\n    }\n    component.prevProps = component.props;\n    component.prevState = component.state;\n    component.prevContext = component.context;\n    component.clearCallBacks();\n    flushMount();\n    invokeEffects(component);\n    return dom;\n}\nfunction unmountComponent(vnode) {\n    var component = vnode.component;\n    component.hooks.forEach(function (hook) {\n        if (isFunction(hook.cleanup)) {\n            hook.cleanup();\n        }\n    });\n    if (isFunction(component.componentWillUnmount)) {\n        errorCatcher(function () {\n            component.componentWillUnmount();\n        }, component);\n    }\n    component._disable = true;\n    unmount(component._rendered);\n    if (!isNullOrUndef(vnode.ref)) {\n        Ref.detach(vnode, vnode.ref, vnode.dom);\n    }\n}\nfunction callGetDerivedStateFromProps(props, state, inst) {\n    var ref = inst.constructor;\n    var getDerivedStateFromProps = ref.getDerivedStateFromProps;\n    var newState;\n    // @TODO show warning\n    errorCatcher(function () {\n        if (isFunction(getDerivedStateFromProps)) {\n            var partialState = getDerivedStateFromProps.call(null, props, state);\n            if (!isUndefined(partialState)) {\n                newState = extend(clone(state), partialState);\n            }\n        }\n    }, inst);\n    return newState;\n}\nfunction callGetSnapshotBeforeUpdate(props, state, inst) {\n    var getSnapshotBeforeUpdate = inst.getSnapshotBeforeUpdate;\n    var snapshot;\n    errorCatcher(function () {\n        if (isFunction(getSnapshotBeforeUpdate)) {\n            snapshot = getSnapshotBeforeUpdate.call(inst, props, state);\n        }\n    }, inst);\n    return snapshot;\n}\nfunction hasNewLifecycle(component) {\n    if (isFunction(component.constructor.getDerivedStateFromProps)) {\n        return true;\n    }\n    return false;\n}\n\nvar items = [];\nfunction enqueueRender(component) {\n    // tslint:disable-next-line:no-conditional-assignment\n    if (!component._dirty && (component._dirty = true) && items.push(component) === 1) {\n        nextTick(rerender);\n    }\n}\nfunction rerender(isForce) {\n    if (isForce === void 0) isForce = false;\n\n    var p;\n    var list = items;\n    items = [];\n    // tslint:disable-next-line:no-conditional-assignment\n    while (p = list.pop()) {\n        if (p._dirty) {\n            updateComponent(p, isForce);\n        }\n    }\n}\n\nvar Component = function Component(props, context) {\n    this._dirty = true;\n    this._disable = true;\n    this._pendingStates = [];\n    this._pendingCallbacks = [];\n    this._afterScheduleEffect = false;\n    this.hooks = [];\n    this.effects = EMPTY_CHILDREN;\n    this.layoutEffects = EMPTY_CHILDREN;\n    if (!this.state) {\n        this.state = {};\n    }\n    this.props = props || {};\n    this.context = context || EMPTY_OBJ;\n    this.refs = {};\n};\nComponent.prototype.setState = function setState(state, callback) {\n    if (state) {\n        this._pendingStates.push(state);\n    }\n    if (isFunction(callback)) {\n        this._pendingCallbacks.push(callback);\n    }\n    if (!this._disable) {\n        enqueueRender(this);\n    }\n};\nComponent.prototype.getState = function getState() {\n    var this$1 = this;\n\n    // tslint:disable-next-line:no-this-assignment\n    var ref = this;\n    var _pendingStates = ref._pendingStates;\n    var state = ref.state;\n    var props = ref.props;\n    if (!_pendingStates.length) {\n        return state;\n    }\n    var stateClone = clone(state);\n    var queue = _pendingStates.concat();\n    this._pendingStates.length = 0;\n    queue.forEach(function (nextState) {\n        if (isFunction(nextState)) {\n            nextState = nextState.call(this$1, state, props);\n        }\n        extend(stateClone, nextState);\n    });\n    return stateClone;\n};\nComponent.prototype.clearCallBacks = function clearCallBacks() {\n    var this$1 = this;\n\n    // cached the length of callbacks, or callbacks may increase by calling them in the same loop\n    var len = this._pendingCallbacks.length;\n    while (this._dirty ? this._pendingCallbacks.length : len) {\n        var cb = this$1._pendingCallbacks.shift();\n        cb.call(this$1);\n        len--;\n    }\n};\nComponent.prototype.forceUpdate = function forceUpdate(callback) {\n    if (isFunction(callback)) {\n        this._pendingCallbacks.push(callback);\n    }\n    updateComponent(this, true);\n};\n// tslint:disable-next-line\nComponent.prototype.render = function render(nextProps, nextState, nextContext) {};\nComponent.prototype.isReactComponent = EMPTY_OBJ;\n\nvar PureComponent = function (Component$$1) {\n    function PureComponent() {\n        Component$$1.apply(this, arguments);\n        this.isPureComponent = true;\n    }\n\n    if (Component$$1) PureComponent.__proto__ = Component$$1;\n    PureComponent.prototype = Object.create(Component$$1 && Component$$1.prototype);\n    PureComponent.prototype.constructor = PureComponent;\n    PureComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\n    };\n\n    return PureComponent;\n}(Component);\n\nvar options = {\n    afterMount: noop$1,\n    afterUpdate: noop$1,\n    beforeUpdate: noop$1,\n    beforeUnmount: noop$1,\n    beforeRender: noop$1,\n    beforeMount: noop$1,\n    afterCreate: noop$1,\n    roots: [],\n    debug: false\n};\n\nfunction render(vnode, container, callback) {\n    if (!container) {\n        throw new Error(container + \" should be a DOM Element\");\n    }\n    var lastVnode = container._component;\n    var dom;\n    options.roots.push(vnode);\n    if (lastVnode !== undefined) {\n        options.roots = options.roots.filter(function (item) {\n            return item !== lastVnode;\n        });\n        dom = patch(lastVnode, vnode, container, {});\n    } else {\n        dom = mountVNode(vnode, {});\n        mountElement(dom, container);\n    }\n    if (container) {\n        container._component = vnode;\n    }\n    flushMount();\n    if (callback) {\n        callback();\n    }\n    return isComposite(vnode) ? vnode.component : dom;\n}\n\nfunction createVNode(type, props, children, key, namespace, owner, ref) {\n    return {\n        type: type,\n        key: key || null,\n        vtype: 2 /* Node */\n        , props: props || EMPTY_OBJ,\n        children: children,\n        namespace: namespace || null,\n        _owner: owner,\n        dom: null,\n        ref: ref || null\n    };\n}\n\nfunction h(type, props, children) {\n    var childNodes;\n    if (props.children) {\n        if (!children) {\n            children = props.children;\n        }\n    }\n    if (isArray(children)) {\n        childNodes = [];\n        addChildren(childNodes, children, type);\n    } else if (isString(children) || isNumber(children)) {\n        children = createVText(String(children));\n    } else if (!isValidElement(children)) {\n        children = EMPTY_CHILDREN;\n    }\n    props.children = childNodes !== undefined ? childNodes : children;\n    return createVNode(type, props, props.children, props.key, props.namespace, props.owner, props.ref);\n}\nfunction addChildren(childNodes, children, type) {\n    if (isString(children) || isNumber(children)) {\n        childNodes.push(createVText(String(children)));\n    } else if (isValidElement(children)) {\n        childNodes.push(children);\n    } else if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            addChildren(childNodes, children[i], type);\n        }\n    } else {\n        childNodes.push(createVoid());\n    }\n}\n\nvar ComponentWrapper = function ComponentWrapper(type, props) {\n    this.vtype = 4 /* Composite */;\n    this.type = type;\n    this.name = type.name;\n    if (isUndefined(this.name)) {\n        var names = type.toString().match(/^function\\s*([^\\s(]+)/);\n        this.name = isArray(names) ? names[0] : 'Component';\n    }\n    type.displayName = this.name;\n    this._owner = props.owner;\n    delete props.owner;\n    if (this.ref = props.ref) {\n        delete props.ref;\n    }\n    if (type._forwarded) {\n        if (!isUndefined(this.ref)) {\n            props.ref = this.ref;\n        }\n        delete this.ref;\n    }\n    this.props = props;\n    this.key = props.key || null;\n    this.dom = null;\n    options.afterCreate(this);\n};\nComponentWrapper.prototype.init = function init(parentContext, parentComponent) {\n    options.beforeMount(this);\n    var dom = mountComponent(this, parentContext, parentComponent);\n    options.afterMount(this);\n    return dom;\n};\nComponentWrapper.prototype.update = function update(previous, current, parentContext, domNode) {\n    this.context = getContextByContextType(this, parentContext);\n    options.beforeUpdate(this);\n    var dom = reRenderComponent(previous, this);\n    options.afterUpdate(this);\n    return dom;\n};\nComponentWrapper.prototype.destroy = function destroy() {\n    options.beforeUnmount(this);\n    unmountComponent(this);\n};\n\n// import StatelessComponent from './stateless-component'\nfunction transformPropsForRealTag(type, props) {\n    var newProps = {};\n    for (var propName in props) {\n        var propValue = props[propName];\n        if (propName === 'defaultValue') {\n            newProps.value = props.value || props.defaultValue;\n            continue;\n        }\n        var svgPropName = SVGPropertyConfig.DOMAttributeNames[propName];\n        if (svgPropName && svgPropName !== propName) {\n            newProps[svgPropName] = propValue;\n            continue;\n        }\n        newProps[propName] = propValue;\n    }\n    return newProps;\n}\n/**\r\n *\r\n * @param props\r\n * @param defaultProps\r\n * defaultProps should respect null but ignore undefined\r\n * @see: https://facebook.github.io/react/docs/react-component.html#defaultprops\r\n */\nfunction transformPropsForComponent(props, defaultProps) {\n    var newProps = {};\n    for (var propName in props) {\n        var propValue = props[propName];\n        newProps[propName] = propValue;\n    }\n    if (defaultProps) {\n        for (var propName$1 in defaultProps) {\n            if (isUndefined(newProps[propName$1])) {\n                newProps[propName$1] = defaultProps[propName$1];\n            }\n        }\n    }\n    return newProps;\n}\nfunction createElement$2(type, properties) {\n    var _children = [],\n        len = arguments.length - 2;\n    while (len-- > 0) _children[len] = arguments[len + 2];\n\n    var children = _children;\n    if (_children) {\n        if (_children.length === 1) {\n            children = _children[0];\n        } else if (_children.length === 0) {\n            children = undefined;\n        }\n    }\n    var props;\n    if (isString(type)) {\n        props = transformPropsForRealTag(type, properties);\n        props.owner = Current.current;\n        return h(type, props, children);\n    } else if (isFunction(type)) {\n        props = transformPropsForComponent(properties, type.defaultProps);\n        if (!props.children || props.children === EMPTY_CHILDREN) {\n            props.children = children || children === 0 ? children : EMPTY_CHILDREN;\n        }\n        props.owner = Current.current;\n        return new ComponentWrapper(type, props);\n    }\n    return type;\n}\n\nfunction cloneElement(vnode, props) {\n    var children = [],\n        len = arguments.length - 2;\n    while (len-- > 0) children[len] = arguments[len + 2];\n\n    if (isVText(vnode)) {\n        return createVText(vnode.text);\n    }\n    if (isString(vnode) || isNumber(vnode)) {\n        return createVText(vnode);\n    }\n    if (isInvalid(vnode) || !isInvalid(vnode) && isPortal(vnode.vtype, vnode) || vnode && vnode.vtype & 16 /* Void */) {\n        return createVoid();\n    }\n    var properties = clone(extend(clone(vnode.props), props));\n    if (vnode.namespace) {\n        properties.namespace = vnode.namespace;\n    }\n    if (vnode.vtype & 4 /* Composite */ && !isNullOrUndef(vnode.ref)) {\n        properties.ref = vnode.ref;\n    }\n    var childrenTmp = (arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children || properties.children) || [];\n    if (childrenTmp.length) {\n        if (childrenTmp.length === 1) {\n            childrenTmp = children[0];\n        }\n    }\n    if (isArray(vnode)) {\n        return vnode.map(function (item) {\n            return cloneElement(item);\n        });\n    }\n    var newVNode = createElement$2(vnode.type, properties);\n    if (isArray(childrenTmp)) {\n        var _children = childrenTmp.map(function (child) {\n            return cloneElement(child, child.props);\n        });\n        if (_children.length === 0) {\n            _children = EMPTY_CHILDREN;\n        }\n        if (isVNode(newVNode)) {\n            newVNode.children = _children;\n        }\n        newVNode.props.children = _children;\n    } else if (childrenTmp) {\n        if (isVNode(newVNode)) {\n            newVNode.children = cloneElement(childrenTmp);\n        }\n        newVNode.props.children = cloneElement(childrenTmp, childrenTmp.props);\n    }\n    return newVNode;\n}\n\nvar Children = {\n    map: function map(children, fn, ctx) {\n        if (isNullOrUndef(children)) {\n            return children;\n        }\n        children = Children.toArray(children);\n        if (ctx && ctx !== children) {\n            fn = fn.bind(ctx);\n        }\n        return children.map(fn);\n    },\n    forEach: function forEach(children, fn, ctx) {\n        if (isNullOrUndef(children)) {\n            return;\n        }\n        children = Children.toArray(children);\n        if (ctx && ctx !== children) {\n            fn = fn.bind(ctx);\n        }\n        for (var i = 0, len = children.length; i < len; i++) {\n            var child = isInvalid(children[i]) ? null : children[i];\n            fn(child, i, children);\n        }\n    },\n    count: function count(children) {\n        children = Children.toArray(children);\n        return children.length;\n    },\n    only: function only(children) {\n        children = Children.toArray(children);\n        if (children.length !== 1) {\n            throw new Error('Children.only() expects only one child.');\n        }\n        return children[0];\n    },\n    toArray: function toArray(children) {\n        if (isNullOrUndef(children)) {\n            return [];\n        }\n        if (isArray(children)) {\n            var result = [];\n            flatten(children, result);\n            return result;\n        }\n        return EMPTY_CHILDREN.concat(children);\n    }\n};\nfunction flatten(arr, result) {\n    for (var i = 0, len = arr.length; i < len; i++) {\n        var value = arr[i];\n        if (isArray(value)) {\n            flatten(value, result);\n        } else {\n            result.push(value);\n        }\n    }\n    return result;\n}\n\n// tslint:disable:no-conditional-assignment\nfunction hydrate(vnode, container, callback) {\n    if (container !== null) {\n        // lastChild causes less reflow than firstChild\n        var dom = container.lastChild;\n        // there should be only a single entry for the root\n        while (dom) {\n            var next = dom.previousSibling;\n            container.removeChild(dom);\n            dom = next;\n        }\n        return render(vnode, container, callback);\n    }\n}\n\nfunction createPortal(children, container) {\n    return {\n        type: container,\n        vtype: 32 /* Portal */\n        , children: children,\n        dom: null\n    };\n}\n\n// some library check React version\n// see: https://github.com/NervJS/nerv/issues/46\nvar version = '15.4.2';\n\nfunction unmountComponentAtNode(dom) {\n    var component = dom._component;\n    if (isValidElement(component)) {\n        unmount(component, dom);\n        delete dom._component;\n        return true;\n    }\n    return false;\n}\nfunction findDOMNode(component) {\n    if (isInvalid(component)) {\n        return null;\n    }\n    return isComponent(component) ? component.vnode.dom : isValidElement(component) ? component.dom : component;\n}\nfunction createFactory(type) {\n    return createElement$2.bind(null, type);\n}\nvar WrapperComponent = function (Component$$1) {\n    function WrapperComponent() {\n        Component$$1.apply(this, arguments);\n    }\n\n    if (Component$$1) WrapperComponent.__proto__ = Component$$1;\n    WrapperComponent.prototype = Object.create(Component$$1 && Component$$1.prototype);\n    WrapperComponent.prototype.constructor = WrapperComponent;\n\n    WrapperComponent.prototype.getChildContext = function getChildContext$$1() {\n        // tslint:disable-next-line\n        return this.props.context;\n    };\n    WrapperComponent.prototype.render = function render$$1() {\n        return this.props.children;\n    };\n\n    return WrapperComponent;\n}(Component);\nfunction unstable_renderSubtreeIntoContainer(parentComponent, vnode, container, callback) {\n    // @TODO: should handle props.context?\n    var wrapper = createElement$2(WrapperComponent, { context: getChildContext(parentComponent, parentComponent.context) }, vnode);\n    var rendered = render(wrapper, container);\n    if (callback) {\n        callback.call(rendered);\n    }\n    return rendered;\n}\nfunction isValidElement$1(element) {\n    return isValidElement(element) && (element.vtype & (4 /* Composite */ | 2 /* Node */)) > 0;\n}\nvar unstable_batchedUpdates = nextTick;\n\nvar shim = noop$1;\nshim.isRequired = noop$1;\nfunction getShim() {\n    return shim;\n}\nvar PropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    PropTypes: {},\n    checkPropTypes: noop$1\n};\nPropTypes.PropTypes = PropTypes;\n\nfunction createRef() {\n    return {};\n}\nfunction forwardRef(cb) {\n    var fn = function (props) {\n        var ref = props.ref;\n        delete props.ref;\n        return cb(props, ref);\n    };\n    fn._forwarded = true;\n    return fn;\n}\n\nfunction memo(component, propsAreEqual) {\n    function shouldComponentUpdate(nextProps) {\n        var prevRef = this.props.ref;\n        var nextRef = nextProps.ref;\n        if (prevRef !== nextRef) {\n            Ref.detach(this.vnode, prevRef, this.dom);\n            Ref.attach(this.vnode, nextRef, this.dom);\n            return true;\n        }\n        return isFunction(propsAreEqual) ? !propsAreEqual(this.props, nextProps) : !shallowEqual(this.props, nextProps);\n    }\n    function Memoed(props) {\n        this.shouldComponentUpdate = shouldComponentUpdate;\n        return createElement$2(component, Object.assign({}, props));\n    }\n    Memoed._forwarded = true;\n    Memoed.isMemo = true;\n    return Memoed;\n}\n\nvar Emiter = function Emiter(value) {\n    this.handlers = [];\n    this.value = value;\n};\nEmiter.prototype.on = function on(handler) {\n    this.handlers.push(handler);\n};\nEmiter.prototype.off = function off(handler) {\n    this.handlers = this.handlers.filter(function (h) {\n        return h !== handler;\n    });\n};\nEmiter.prototype.set = function set(value) {\n    var this$1 = this;\n\n    this.value = value;\n    this.handlers.forEach(function (h) {\n        return h(this$1.value);\n    });\n};\n\nvar uid = 0;\nfunction onlyChild(children) {\n    return Array.isArray(children) ? children[0] : children;\n}\nfunction createContext(defaultValue) {\n    var contextProp = '__context_' + uid++ + '__';\n    var Provider = function (Component$$1) {\n        function Provider() {\n            Component$$1.apply(this, arguments);\n            this.emiter = new Emiter(this.props.value);\n        }\n\n        if (Component$$1) Provider.__proto__ = Component$$1;\n        Provider.prototype = Object.create(Component$$1 && Component$$1.prototype);\n        Provider.prototype.constructor = Provider;\n        Provider.prototype.getChildContext = function getChildContext() {\n            return obj = {}, obj[contextProp] = this.emiter, obj;\n            var obj;\n        };\n        Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n            if (!objectIs(this.props.value, nextProps.value)) {\n                this.emiter.set(nextProps.value);\n            }\n        };\n        Provider.prototype.render = function render() {\n            return this.props.children;\n        };\n\n        return Provider;\n    }(Component);\n    Provider.isContextProvider = true;\n    // tslint:disable-next-line: max-classes-per-file\n    var Consumer = function (Component$$1) {\n        function Consumer() {\n            var this$1 = this;\n\n            Component$$1.apply(this, arguments);\n            this.state = {\n                value: this.getContextValue()\n            };\n            this.onUpdate = function (value) {\n                if (!objectIs(value, this$1.state.value)) {\n                    this$1.setState({\n                        value: this$1.getContextValue()\n                    });\n                }\n            };\n        }\n\n        if (Component$$1) Consumer.__proto__ = Component$$1;\n        Consumer.prototype = Object.create(Component$$1 && Component$$1.prototype);\n        Consumer.prototype.constructor = Consumer;\n        Consumer.prototype.componentWillMount = function componentWillMount() {\n            var emiter = this.context[contextProp];\n            if (emiter) {\n                emiter.off(this.onUpdate);\n            }\n        };\n        Consumer.prototype.componentDidMount = function componentDidMount() {\n            var emiter = this.context[contextProp];\n            if (emiter) {\n                emiter.on(this.onUpdate);\n            }\n        };\n        Consumer.prototype.getContextValue = function getContextValue() {\n            var emiter = this.context[contextProp];\n            return isUndefined(emiter) ? defaultValue : emiter.value;\n        };\n        Consumer.prototype.render = function render() {\n            return onlyChild(this.props.children)(this.state.value);\n        };\n\n        return Consumer;\n    }(Component);\n    Consumer.isContextConsumer = true;\n    return {\n        Provider: Provider,\n        Consumer: Consumer,\n        _id: contextProp,\n        _defaultValue: defaultValue\n    };\n}\n\nfunction Fragment(props) {\n    return props.children;\n}\n\n// tslint:disable-next-line: max-line-length\nvar index = {\n    Children: Children,\n    Component: Component,\n    PureComponent: PureComponent,\n    createElement: createElement$2,\n    cloneElement: cloneElement,\n    render: render,\n    nextTick: nextTick,\n    options: options,\n    findDOMNode: findDOMNode,\n    isValidElement: isValidElement$1,\n    unmountComponentAtNode: unmountComponentAtNode,\n    createPortal: createPortal,\n    unstable_renderSubtreeIntoContainer: unstable_renderSubtreeIntoContainer,\n    hydrate: hydrate,\n    createFactory: createFactory,\n    unstable_batchedUpdates: unstable_batchedUpdates,\n    version: version,\n    PropTypes: PropTypes,\n    createRef: createRef,\n    forwardRef: forwardRef,\n    memo: memo,\n    createContext: createContext,\n    renderComponent: renderComponent,\n    getHooks: getHooks,\n    Current: Current,\n    useEffect: useEffect, useLayoutEffect: useLayoutEffect, useReducer: useReducer, useState: useState, useRef: useRef, useCallback: useCallback, useMemo: useMemo, useImperativeHandle: useImperativeHandle, useContext: useContext,\n    Fragment: Fragment\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.PureComponent = PureComponent;\nexports.createElement = createElement$2;\nexports.cloneElement = cloneElement;\nexports.render = render;\nexports.nextTick = nextTick;\nexports.options = options;\nexports.findDOMNode = findDOMNode;\nexports.isValidElement = isValidElement$1;\nexports.unmountComponentAtNode = unmountComponentAtNode;\nexports.createPortal = createPortal;\nexports.unstable_renderSubtreeIntoContainer = unstable_renderSubtreeIntoContainer;\nexports.hydrate = hydrate;\nexports.createFactory = createFactory;\nexports.unstable_batchedUpdates = unstable_batchedUpdates;\nexports.version = version;\nexports.PropTypes = PropTypes;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.memo = memo;\nexports.createContext = createContext;\nexports.renderComponent = renderComponent;\nexports.getHooks = getHooks;\nexports.Current = Current;\nexports.Fragment = Fragment;\nexports.useEffect = useEffect;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useReducer = useReducer;\nexports.useState = useState;\nexports.useRef = useRef;\nexports.useCallback = useCallback;\nexports.useMemo = useMemo;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useContext = useContext;\nexports['default'] = index;\n//# sourceMappingURL=index.js.map\n"]}