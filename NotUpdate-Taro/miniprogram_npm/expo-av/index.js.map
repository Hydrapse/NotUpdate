{"version":3,"sources":["index.js","Audio.js","ExponentAV.js","Audio/Recording.js","AV.js","Audio/AudioAvailability.js","Audio/Sound.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA;AFOA,AENA;AFOA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AENA;ACFA,AHSA,AIZA,AFMA;ACFA,AHSA,AIZA,AFMA;ACFA,AHSA,AIZA,AFMA;ACFA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,AHSA,AENA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA,AGTA;AFOA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./Audio');var Audio = __REQUIRE_WILDCARD__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'Audio', { enumerable: true, configurable: true, get: function() { return Audio; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./Video');Object.defineProperty(exports, 'Video', { enumerable: true, configurable: true, get: function() { return __TEMP__.default; } });\n//# sourceMappingURL=index.js.map","var __TEMP__ = require('./ExponentAV');var ExponentAV = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./Audio/Recording');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./Audio/Sound');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./Audio/AudioAvailability');Object.defineProperty(exports, 'setIsEnabledAsync', { enumerable: true, configurable: true, get: function() { return __TEMP__.setIsEnabledAsync; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./AV');Object.defineProperty(exports, 'PitchCorrectionQuality', { enumerable: true, configurable: true, get: function() { return __TEMP__.PitchCorrectionQuality; } });\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = exports.INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS = 0;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var INTERRUPTION_MODE_IOS_DO_NOT_MIX = exports.INTERRUPTION_MODE_IOS_DO_NOT_MIX = 1;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var INTERRUPTION_MODE_IOS_DUCK_OTHERS = exports.INTERRUPTION_MODE_IOS_DUCK_OTHERS = 2;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = exports.INTERRUPTION_MODE_ANDROID_DO_NOT_MIX = 1;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = exports.INTERRUPTION_MODE_ANDROID_DUCK_OTHERS = 2;\n// Returns true if value is in validValues, and false if not.\nconst _isValueValid = (value, validValues) => {\n    return validValues.filter(validValue => validValue === value).length > 0;\n};\n// Returns array of missing keys in object. Returns an empty array if no missing keys are found.\nconst _findMissingKeys = (object, requiredKeys) => {\n    return requiredKeys.filter(requiredKey => !(requiredKey in object));\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.setAudioModeAsync = async function setAudioModeAsync(mode) {\n    const missingKeys = _findMissingKeys(mode, [\n        'allowsRecordingIOS',\n        'interruptionModeIOS',\n        'playsInSilentModeIOS',\n        'staysActiveInBackground',\n        'interruptionModeAndroid',\n        'shouldDuckAndroid',\n        'playThroughEarpieceAndroid',\n    ]);\n    if (missingKeys.length > 0) {\n        throw new Error(`Audio mode attempted to be set without the required keys: ${JSON.stringify(missingKeys)}`);\n    }\n    if (!_isValueValid(mode.interruptionModeIOS, [\n        INTERRUPTION_MODE_IOS_MIX_WITH_OTHERS,\n        INTERRUPTION_MODE_IOS_DO_NOT_MIX,\n        INTERRUPTION_MODE_IOS_DUCK_OTHERS,\n    ])) {\n        throw new Error(`\"interruptionModeIOS\" was set to an invalid value.`);\n    }\n    if (!_isValueValid(mode.interruptionModeAndroid, [\n        INTERRUPTION_MODE_ANDROID_DO_NOT_MIX,\n        INTERRUPTION_MODE_ANDROID_DUCK_OTHERS,\n    ])) {\n        throw new Error(`\"interruptionModeAndroid\" was set to an invalid value.`);\n    }\n    if (typeof mode.allowsRecordingIOS !== 'boolean' ||\n        typeof mode.playsInSilentModeIOS !== 'boolean' ||\n        typeof mode.staysActiveInBackground !== 'boolean' ||\n        typeof mode.shouldDuckAndroid !== 'boolean' ||\n        typeof mode.playThroughEarpieceAndroid !== 'boolean') {\n        throw new Error('\"allowsRecordingIOS\", \"playsInSilentModeIOS\", \"playThroughEarpieceAndroid\", \"staysActiveInBackground\" and \"shouldDuckAndroid\" must be booleans.');\n    }\n    return await ExponentAV.setAudioMode(mode);\n};\n//# sourceMappingURL=Audio.js.map","var __TEMP__ = require('@unimodules/core');var NativeModulesProxy = __TEMP__['NativeModulesProxy'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = NativeModulesProxy.ExponentAV;\n//# sourceMappingURL=ExponentAV.js.map","var __TEMP__ = require('@unimodules/core');var EventEmitter = __TEMP__['EventEmitter'];var Platform = __TEMP__['Platform'];\nvar __TEMP__ = require('../AV');var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = __TEMP__['_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS'];\nvar __TEMP__ = require('../ExponentAV');var ExponentAV = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./AudioAvailability');var isAudioEnabled = __TEMP__['isAudioEnabled'];var throwIfAudioIsDisabled = __TEMP__['throwIfAudioIsDisabled'];\nvar __TEMP__ = require('./Sound');var Sound = __TEMP__['Sound'];\n// TODO: consider changing these to enums\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_DEFAULT = 0;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP = 1;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4 = 2;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_NB = 3;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AMR_WB = 4;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADIF = 5;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_AAC_ADTS = 6;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_RTP_AVP = 7;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG2TS = 8;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = exports.RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_WEBM = 9;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_DEFAULT = 0;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB = 1;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_WB = 2;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC = 3;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_HE_AAC = 4;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = exports.RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC_ELD = 5;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_LINEARPCM = 'lpcm';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AC3 = 'ac-3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_60958AC3 = 'cac3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLEIMA4 = 'ima4';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC = 'aac ';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4CELP = 'celp';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4HVXC = 'hvxc';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4TWINVQ = 'twvq';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE3 = 'MAC3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MACE6 = 'MAC6';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ULAW = 'ulaw';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ALAW = 'alaw';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN = 'QDMC';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QDESIGN2 = 'QDM2';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_QUALCOMM = 'Qclp';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER1 = '.mp1';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER2 = '.mp2';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEGLAYER3 = '.mp3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_APPLELOSSLESS = 'alac';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE = 'aach';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_LD = 'aacl';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD = 'aace';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_SBR = 'aacf';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_ELD_V2 = 'aacg';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_HE_V2 = 'aacp';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MPEG4AAC_SPATIAL = 'aacs';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR = 'samr';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AMR_WB = 'sawb';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AUDIBLE = 'AUDB';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ILBC = 'ilbc';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_DVIINTELIMA = 0x6d730011;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_MICROSOFTGSM = 0x6d730031;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_AES3 = 'aes3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = exports.RECORDING_OPTION_IOS_OUTPUT_FORMAT_ENHANCEDAC3 = 'ec-3';\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN = 0;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_LOW = 0x20;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MEDIUM = 0x40;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_HIGH = 0x60;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = exports.RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX = 0x7f;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_CONSTANT = 0;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_LONG_TERM_AVERAGE = 1;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE_CONSTRAINED = 2;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = exports.RECORDING_OPTION_IOS_BIT_RATE_STRATEGY_VARIABLE = 3;\n// TODO : maybe make presets for music and speech, or lossy / lossless.\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTIONS_PRESET_HIGH_QUALITY = exports.RECORDING_OPTIONS_PRESET_HIGH_QUALITY = {\n    android: {\n        extension: '.m4a',\n        outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_MPEG_4,\n        audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AAC,\n        sampleRate: 44100,\n        numberOfChannels: 2,\n        bitRate: 128000,\n    },\n    ios: {\n        extension: '.caf',\n        audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MAX,\n        sampleRate: 44100,\n        numberOfChannels: 2,\n        bitRate: 128000,\n        linearPCMBitDepth: 16,\n        linearPCMIsBigEndian: false,\n        linearPCMIsFloat: false,\n    },\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var RECORDING_OPTIONS_PRESET_LOW_QUALITY = exports.RECORDING_OPTIONS_PRESET_LOW_QUALITY = {\n    android: {\n        extension: '.3gp',\n        outputFormat: RECORDING_OPTION_ANDROID_OUTPUT_FORMAT_THREE_GPP,\n        audioEncoder: RECORDING_OPTION_ANDROID_AUDIO_ENCODER_AMR_NB,\n        sampleRate: 44100,\n        numberOfChannels: 2,\n        bitRate: 128000,\n    },\n    ios: {\n        extension: '.caf',\n        audioQuality: RECORDING_OPTION_IOS_AUDIO_QUALITY_MIN,\n        sampleRate: 44100,\n        numberOfChannels: 2,\n        bitRate: 128000,\n        linearPCMBitDepth: 16,\n        linearPCMIsBigEndian: false,\n        linearPCMIsFloat: false,\n    },\n};\nlet _recorderExists = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.Recording = class Recording {\n    constructor() {\n        this._subscription = null;\n        this._canRecord = false;\n        this._isDoneRecording = false;\n        this._finalDurationMillis = 0;\n        this._uri = null;\n        this._onRecordingStatusUpdate = null;\n        this._progressUpdateTimeoutVariable = null;\n        this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n        this._options = null;\n        // Internal methods\n        this._cleanupForUnloadedRecorder = async (finalStatus) => {\n            this._canRecord = false;\n            this._isDoneRecording = true;\n            // $FlowFixMe(greg): durationMillis is not always defined\n            this._finalDurationMillis = finalStatus.durationMillis;\n            _recorderExists = false;\n            if (this._subscription) {\n                this._subscription.remove();\n                this._subscription = null;\n            }\n            this._disablePolling();\n            return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n        };\n        this._pollingLoop = async () => {\n            if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n                this._progressUpdateTimeoutVariable = setTimeout(this._pollingLoop, this._progressUpdateIntervalMillis);\n                try {\n                    await this.getStatusAsync();\n                }\n                catch (error) {\n                    this._disablePolling();\n                }\n            }\n        };\n        // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n        // Get status API\n        this.getStatusAsync = async () => {\n            // Automatically calls onRecordingStatusUpdate.\n            if (this._canRecord) {\n                return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n            }\n            const status = {\n                canRecord: false,\n                isRecording: false,\n                isDoneRecording: this._isDoneRecording,\n                durationMillis: this._finalDurationMillis,\n            };\n            this._callOnRecordingStatusUpdateForNewStatus(status);\n            return status;\n        };\n    }\n    _disablePolling() {\n        if (this._progressUpdateTimeoutVariable != null) {\n            clearTimeout(this._progressUpdateTimeoutVariable);\n            this._progressUpdateTimeoutVariable = null;\n        }\n    }\n    _enablePollingIfNecessaryAndPossible() {\n        if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n            this._disablePolling();\n            this._pollingLoop();\n        }\n    }\n    _callOnRecordingStatusUpdateForNewStatus(status) {\n        if (this._onRecordingStatusUpdate != null) {\n            this._onRecordingStatusUpdate(status);\n        }\n    }\n    async _performOperationAndHandleStatusAsync(operation) {\n        throwIfAudioIsDisabled();\n        if (this._canRecord) {\n            const status = await operation();\n            this._callOnRecordingStatusUpdateForNewStatus(status);\n            return status;\n        }\n        else {\n            throw new Error('Cannot complete operation because this recorder is not ready to record.');\n        }\n    }\n    setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n        this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n        if (onRecordingStatusUpdate == null) {\n            this._disablePolling();\n        }\n        else {\n            this._enablePollingIfNecessaryAndPossible();\n        }\n        this.getStatusAsync();\n    }\n    setProgressUpdateInterval(progressUpdateIntervalMillis) {\n        this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n        this.getStatusAsync();\n    }\n    // Record API\n    async prepareToRecordAsync(options = RECORDING_OPTIONS_PRESET_LOW_QUALITY) {\n        throwIfAudioIsDisabled();\n        if (_recorderExists) {\n            throw new Error('Only one Recording object can be prepared at a given time.');\n        }\n        if (this._isDoneRecording) {\n            throw new Error('This Recording object is done recording; you must make a new one.');\n        }\n        if (!options || !options.android || !options.ios) {\n            throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n        }\n        const extensionRegex = /^\\.\\w+$/;\n        if (!options.android.extension ||\n            !options.ios.extension ||\n            !extensionRegex.test(options.android.extension) ||\n            !extensionRegex.test(options.ios.extension)) {\n            throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n        }\n        if (!this._canRecord) {\n            if (eventEmitter) {\n                this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n            }\n            const { uri, status, } = await ExponentAV.prepareAudioRecorder(options);\n            _recorderExists = true;\n            this._uri = uri;\n            this._options = options;\n            this._canRecord = true;\n            const currentStatus = { ...status, canRecord: true };\n            this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n            this._enablePollingIfNecessaryAndPossible();\n            return currentStatus;\n        }\n        else {\n            throw new Error('This Recording object is already prepared to record.');\n        }\n    }\n    async startAsync() {\n        return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n    }\n    async pauseAsync() {\n        return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n    }\n    async stopAndUnloadAsync() {\n        if (!this._canRecord) {\n            if (this._isDoneRecording) {\n                throw new Error('Cannot unload a Recording that has already been unloaded.');\n            }\n            else {\n                throw new Error('Cannot unload a Recording that has not been prepared.');\n            }\n        }\n        // We perform a separate native API call so that the state of the Recording can be updated with\n        // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n        const finalStatus = await ExponentAV.stopAudioRecording();\n        await ExponentAV.unloadAudioRecorder();\n        return this._cleanupForUnloadedRecorder(finalStatus);\n    }\n    // Read API\n    getURI() {\n        return this._uri;\n    }\n    async createNewLoadedSound(initialStatus = {}, onPlaybackStatusUpdate = null) {\n        console.warn(`createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`);\n        return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n    }\n    async createNewLoadedSoundAsync(initialStatus = {}, onPlaybackStatusUpdate = null) {\n        if (this._uri == null || !this._isDoneRecording) {\n            throw new Error('Cannot create sound when the Recording has not finished!');\n        }\n        return Sound.createAsync(\n        // $FlowFixMe: Flow can't distinguish between this literal and Asset\n        { uri: this._uri }, initialStatus, onPlaybackStatusUpdate, false);\n    }\n};\n//# sourceMappingURL=Recording.js.map","var __TEMP__ = require('./ExponentAV');var ExponentAV = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('expo-asset');var Asset = __TEMP__['Asset'];\nvar __TEMP__ = require('@unimodules/core');var Platform = __TEMP__['Platform'];\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var PitchCorrectionQuality = exports.PitchCorrectionQuality = undefined;\n(function (PitchCorrectionQuality) {\n    PitchCorrectionQuality[PitchCorrectionQuality[\"Low\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Low] = \"Low\";\n    PitchCorrectionQuality[PitchCorrectionQuality[\"Medium\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.Medium] = \"Medium\";\n    PitchCorrectionQuality[PitchCorrectionQuality[\"High\"] = ExponentAV && ExponentAV.Qualities && ExponentAV.Qualities.High] = \"High\";\n})(PitchCorrectionQuality || (PitchCorrectionQuality = {}));\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = exports._DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var _DEFAULT_INITIAL_PLAYBACK_STATUS = exports._DEFAULT_INITIAL_PLAYBACK_STATUS = {\n    positionMillis: 0,\n    progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n    shouldPlay: false,\n    rate: 1.0,\n    shouldCorrectPitch: false,\n    volume: 1.0,\n    isMuted: false,\n    isLooping: false,\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getNativeSourceFromSource = function getNativeSourceFromSource(source) {\n    let uri = null;\n    let overridingExtension = null;\n    let headers;\n    if (typeof source === 'string' && Platform.OS === 'web') {\n        return {\n            uri: source,\n            overridingExtension,\n            headers,\n        };\n    }\n    let asset = _getAssetFromPlaybackSource(source);\n    if (asset != null) {\n        uri = asset.localUri || asset.uri;\n    }\n    else if (source != null &&\n        typeof source !== 'number' &&\n        'uri' in source &&\n        typeof source.uri === 'string') {\n        uri = source.uri;\n    }\n    if (uri == null) {\n        return null;\n    }\n    if (source != null &&\n        typeof source !== 'number' &&\n        'overrideFileExtensionAndroid' in source &&\n        typeof source.overrideFileExtensionAndroid === 'string') {\n        overridingExtension = source.overrideFileExtensionAndroid;\n    }\n    if (source != null &&\n        typeof source !== 'number' &&\n        'headers' in source &&\n        typeof source.headers === 'object') {\n        headers = source.headers;\n    }\n    return { uri, overridingExtension, headers };\n};\nfunction _getAssetFromPlaybackSource(source) {\n    if (source == null) {\n        return null;\n    }\n    let asset = null;\n    if (typeof source === 'number') {\n        asset = Asset.fromModule(source);\n    }\n    else if (source instanceof Asset) {\n        asset = source;\n    }\n    return asset;\n}\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.assertStatusValuesInBounds = function assertStatusValuesInBounds(status) {\n    if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n        throw new RangeError('Rate value must be between 0.0 and 32.0');\n    }\n    if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n        throw new RangeError('Volume value must be between 0.0 and 1.0');\n    }\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getNativeSourceAndFullInitialStatusForLoadAsync = async function getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst) {\n    // Get the full initial status\n    const fullInitialStatus = initialStatus == null\n        ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n        : {\n            ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n            ...initialStatus,\n        };\n    assertStatusValuesInBounds(fullInitialStatus);\n    if (typeof source === 'string' && Platform.OS === 'web') {\n        return {\n            nativeSource: {\n                uri: source,\n                overridingExtension: null,\n            },\n            fullInitialStatus,\n        };\n    }\n    // Download first if necessary.\n    let asset = _getAssetFromPlaybackSource(source);\n    if (downloadFirst && asset) {\n        // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n        await asset.downloadAsync();\n    }\n    // Get the native source\n    const nativeSource = getNativeSourceFromSource(source);\n    if (nativeSource === null) {\n        throw new Error(`Cannot load an AV asset from a null playback source`);\n    }\n    return { nativeSource, fullInitialStatus };\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getUnloadedStatus = function getUnloadedStatus(error = null) {\n    return {\n        isLoaded: false,\n        ...(error ? { error } : null),\n    };\n};\n/**\n * A mixin that defines common playback methods for A/V classes so they implement the `Playback`\n * interface\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var PlaybackMixin = exports.PlaybackMixin = {\n    async playAsync() {\n        return this.setStatusAsync({ shouldPlay: true });\n    },\n    async playFromPositionAsync(positionMillis, tolerances = {}) {\n        return this.setStatusAsync({\n            positionMillis,\n            shouldPlay: true,\n            seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n            seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n        });\n    },\n    async pauseAsync() {\n        return this.setStatusAsync({ shouldPlay: false });\n    },\n    async stopAsync() {\n        return this.setStatusAsync({ positionMillis: 0, shouldPlay: false });\n    },\n    async setPositionAsync(positionMillis, tolerances = {}) {\n        return this.setStatusAsync({\n            positionMillis,\n            seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n            seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n        });\n    },\n    async setRateAsync(rate, shouldCorrectPitch = false, pitchCorrectionQuality = PitchCorrectionQuality.Low) {\n        return this.setStatusAsync({\n            rate,\n            shouldCorrectPitch,\n            pitchCorrectionQuality,\n        });\n    },\n    async setVolumeAsync(volume) {\n        return this.setStatusAsync({ volume });\n    },\n    async setIsMutedAsync(isMuted) {\n        return this.setStatusAsync({ isMuted });\n    },\n    async setIsLoopingAsync(isLooping) {\n        return this.setStatusAsync({ isLooping });\n    },\n    async setProgressUpdateIntervalAsync(progressUpdateIntervalMillis) {\n        return this.setStatusAsync({ progressUpdateIntervalMillis });\n    },\n};\n//# sourceMappingURL=AV.js.map","var __TEMP__ = require('../ExponentAV');var ExponentAV = __REQUIRE_DEFAULT__(__TEMP__);\nlet _enabled = true;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.isAudioEnabled = function isAudioEnabled() {\n    return _enabled;\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.throwIfAudioIsDisabled = function throwIfAudioIsDisabled() {\n    if (!_enabled) {\n        throw new Error('Cannot complete operation because audio is not enabled.');\n    }\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.setIsEnabledAsync = async function setIsEnabledAsync(value) {\n    _enabled = value;\n    await ExponentAV.setAudioIsEnabled(value);\n    // TODO : We immediately pause all players when disabled, but we do not resume all shouldPlay\n    // players when enabled. Perhaps for completeness we should allow this; the design of the\n    // enabling API is for people to enable / disable this audio library, but I think that it should\n    // intuitively also double as a global pause/resume.\n};\n//# sourceMappingURL=AudioAvailability.js.map","var __TEMP__ = require('@unimodules/core');var EventEmitter = __TEMP__['EventEmitter'];\nvar __TEMP__ = require('./AudioAvailability');var throwIfAudioIsDisabled = __TEMP__['throwIfAudioIsDisabled'];\nvar __TEMP__ = require('../AV');var PlaybackMixin = __TEMP__['PlaybackMixin'];var assertStatusValuesInBounds = __TEMP__['assertStatusValuesInBounds'];var getNativeSourceAndFullInitialStatusForLoadAsync = __TEMP__['getNativeSourceAndFullInitialStatusForLoadAsync'];var getUnloadedStatus = __TEMP__['getUnloadedStatus'];\nvar __TEMP__ = require('../ExponentAV');var ExponentAV = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.Sound = class Sound {\n    constructor() {\n        this._loaded = false;\n        this._loading = false;\n        this._key = null;\n        this._lastStatusUpdate = null;\n        this._lastStatusUpdateTime = null;\n        this._subscriptions = [];\n        this._eventEmitter = new EventEmitter(ExponentAV);\n        this._coalesceStatusUpdatesInMillis = 100;\n        this._onPlaybackStatusUpdate = null;\n        this._internalStatusUpdateCallback = ({ key, status, }) => {\n            if (this._key === key) {\n                this._callOnPlaybackStatusUpdateForNewStatus(status);\n            }\n        };\n        this._internalErrorCallback = ({ key, error }) => {\n            if (this._key === key) {\n                this._errorCallback(error);\n            }\n        };\n        this._errorCallback = (error) => {\n            this._clearSubscriptions();\n            this._loaded = false;\n            this._key = null;\n            this._callOnPlaybackStatusUpdateForNewStatus(getUnloadedStatus(error));\n        };\n        // ### Unified playback API ### (consistent with Video.js)\n        // All calls automatically call onPlaybackStatusUpdate as a side effect.\n        // Get status API\n        this.getStatusAsync = async () => {\n            if (this._loaded) {\n                return this._performOperationAndHandleStatusAsync(() => ExponentAV.getStatusForSound(this._key));\n            }\n            const status = getUnloadedStatus();\n            this._callOnPlaybackStatusUpdateForNewStatus(status);\n            return status;\n        };\n    }\n    // Internal methods\n    _callOnPlaybackStatusUpdateForNewStatus(status) {\n        const shouldDismissBasedOnCoalescing = this._lastStatusUpdateTime &&\n            JSON.stringify(status) === this._lastStatusUpdate &&\n            Date.now() - this._lastStatusUpdateTime.getTime() < this._coalesceStatusUpdatesInMillis;\n        if (this._onPlaybackStatusUpdate != null && !shouldDismissBasedOnCoalescing) {\n            this._onPlaybackStatusUpdate(status);\n            this._lastStatusUpdateTime = new Date();\n            this._lastStatusUpdate = JSON.stringify(status);\n        }\n    }\n    async _performOperationAndHandleStatusAsync(operation) {\n        throwIfAudioIsDisabled();\n        if (this._loaded) {\n            const status = await operation();\n            this._callOnPlaybackStatusUpdateForNewStatus(status);\n            return status;\n        }\n        else {\n            throw new Error('Cannot complete operation because sound is not loaded.');\n        }\n    }\n    // TODO: We can optimize by only using time observer on native if (this._onPlaybackStatusUpdate).\n    _subscribeToNativeEvents() {\n        if (this._loaded) {\n            this._subscriptions.push(this._eventEmitter.addListener('didUpdatePlaybackStatus', this._internalStatusUpdateCallback));\n            this._subscriptions.push(this._eventEmitter.addListener('ExponentAV.onError', this._internalErrorCallback));\n        }\n    }\n    _clearSubscriptions() {\n        this._subscriptions.forEach(e => e.remove());\n        this._subscriptions = [];\n    }\n    setOnPlaybackStatusUpdate(onPlaybackStatusUpdate) {\n        this._onPlaybackStatusUpdate = onPlaybackStatusUpdate;\n        this.getStatusAsync();\n    }\n    // Loading / unloading API\n    async loadAsync(source, initialStatus = {}, downloadFirst = true) {\n        throwIfAudioIsDisabled();\n        if (this._loading) {\n            throw new Error('The Sound is already loading.');\n        }\n        if (!this._loaded) {\n            this._loading = true;\n            const { nativeSource, fullInitialStatus, } = await getNativeSourceAndFullInitialStatusForLoadAsync(source, initialStatus, downloadFirst);\n            // This is a workaround, since using load with resolve / reject seems to not work.\n            return new Promise((resolve, reject) => {\n                const loadSuccess = (result) => {\n                    const [key, status] = result;\n                    this._key = key;\n                    this._loaded = true;\n                    this._loading = false;\n                    this._subscribeToNativeEvents();\n                    this._callOnPlaybackStatusUpdateForNewStatus(status);\n                    resolve(status);\n                };\n                const loadError = (error) => {\n                    this._loading = false;\n                    reject(error);\n                };\n                ExponentAV.loadForSound(nativeSource, fullInitialStatus)\n                    .then(loadSuccess)\n                    .catch(loadError);\n            });\n        }\n        else {\n            throw new Error('The Sound is already loaded.');\n        }\n    }\n    async unloadAsync() {\n        if (this._loaded) {\n            this._loaded = false;\n            const key = this._key;\n            this._key = null;\n            const status = await ExponentAV.unloadForSound(key);\n            this._callOnPlaybackStatusUpdateForNewStatus(status);\n            this._clearSubscriptions();\n            return status;\n        }\n        else {\n            return this.getStatusAsync(); // Automatically calls onPlaybackStatusUpdate.\n        }\n    }\n    // Set status API (only available while isLoaded = true)\n    async setStatusAsync(status) {\n        assertStatusValuesInBounds(status);\n        return this._performOperationAndHandleStatusAsync(() => ExponentAV.setStatusForSound(this._key, status));\n    }\n    async replayAsync(status = {}) {\n        if (status.positionMillis && status.positionMillis !== 0) {\n            throw new Error('Requested position after replay has to be 0.');\n        }\n        return this._performOperationAndHandleStatusAsync(() => ExponentAV.replaySound(this._key, {\n            ...status,\n            positionMillis: 0,\n            shouldPlay: true,\n        }));\n    }\n};\nSound.create = async (source, initialStatus = {}, onPlaybackStatusUpdate = null, downloadFirst = true) => {\n    console.warn(`Sound.create is deprecated in favor of Sound.createAsync with the same API except for the new method name`);\n    return Sound.createAsync(source, initialStatus, onPlaybackStatusUpdate, downloadFirst);\n};\nSound.createAsync = async (source, initialStatus = {}, onPlaybackStatusUpdate = null, downloadFirst = true) => {\n    const sound = new Sound();\n    sound.setOnPlaybackStatusUpdate(onPlaybackStatusUpdate);\n    const status = await sound.loadAsync(source, initialStatus, downloadFirst);\n    return { sound, status };\n};\nObject.assign(Sound.prototype, PlaybackMixin);\n//# sourceMappingURL=Sound.js.map"]}