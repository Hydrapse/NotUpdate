{"version":3,"sources":["index.js","Asset.fx.js","Asset.js","AssetRegistry.js","resolveAssetSource.js","AssetSources.js","AssetSourceResolver.js","AssetUris.js","EmbeddedAssets.js","ImageAssets.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA;ADIA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AENA;AHUA,ACHA,AGTA,ADGA;AFOA,AGTA;AHUA,AGTA;AHUA,AIZA,ADGA;AHUA,AIZA,ADGA;AHUA,AIZA,ADGA;AHUA,AIZA,ADGA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA,ACHA;ANmBA,AGTA,AENA,ACHA;ANmBA,AGTA,AENA,ACHA;ANmBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,ACHA,ACHA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA,AENA;ALgBA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var __TEMP__ = require('./Asset.fx');\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('./Asset');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\n//# sourceMappingURL=index.js.map","var __TEMP__ = require('./Asset');var Asset = __TEMP__['Asset'];\nvar __TEMP__ = require('./resolveAssetSource');var setCustomSourceTransformer = __TEMP__['setCustomSourceTransformer'];\n// Override React Native's asset resolution for `Image` components\nsetCustomSourceTransformer(resolver => {\n    try {\n        const asset = Asset.fromMetadata(resolver.asset);\n        return resolver.fromSource(asset.downloaded ? asset.localUri : asset.uri);\n    }\n    catch (e) {\n        return resolver.defaultAsset();\n    }\n});\n//# sourceMappingURL=Asset.fx.js.map","var __TEMP__ = require('@unimodules/core');var Platform = __TEMP__['Platform'];\nvar __TEMP__ = require('expo-file-system');var FileSystem = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('expo-constants');var Constants = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('blueimp-md5');var computeMd5 = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./AssetRegistry');var getAssetByID = __TEMP__['getAssetByID'];\nvar __TEMP__ = require('./resolveAssetSource');var resolveAssetSource = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./AssetSources');var AssetSources = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./AssetUris');var AssetUris = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./EmbeddedAssets');var EmbeddedAssets = __REQUIRE_WILDCARD__(__TEMP__);\nvar __TEMP__ = require('./ImageAssets');var ImageAssets = __REQUIRE_WILDCARD__(__TEMP__);\nconst IS_MANAGED_ENV = !!Constants.appOwnership;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.Asset = class Asset {\n    constructor({ name, type, hash = null, uri, width, height }) {\n        this.hash = null;\n        this.localUri = null;\n        this.width = null;\n        this.height = null;\n        this.downloading = false;\n        this.downloaded = false;\n        this._downloadCallbacks = [];\n        this.name = name;\n        this.type = type;\n        this.hash = hash;\n        this.uri = uri;\n        if (typeof width === 'number') {\n            this.width = width;\n        }\n        if (typeof height === 'number') {\n            this.height = height;\n        }\n        // This only applies to assets that are bundled in Expo standalone apps\n        if (IS_MANAGED_ENV && hash) {\n            this.localUri = EmbeddedAssets.getEmbeddedAssetUri(hash, type);\n            if (this.localUri) {\n                this.downloaded = true;\n            }\n        }\n    }\n    static loadAsync(moduleId) {\n        const moduleIds = Array.isArray(moduleId) ? moduleId : [moduleId];\n        return Promise.all(moduleIds.map(moduleId => Asset.fromModule(moduleId).downloadAsync()));\n    }\n    static fromModule(virtualAssetModule) {\n        if (typeof virtualAssetModule === 'string') {\n            return Asset.fromURI(virtualAssetModule);\n        }\n        const meta = getAssetByID(virtualAssetModule);\n        if (!meta) {\n            throw new Error(`Module \"${virtualAssetModule}\" is missing from the asset registry`);\n        }\n        // Outside of the managed env we need the moduleId to initialize the asset\n        // because resolveAssetSource depends on it\n        if (!IS_MANAGED_ENV) {\n            const { uri } = resolveAssetSource(virtualAssetModule);\n            const asset = new Asset({\n                name: meta.name,\n                type: meta.type,\n                hash: meta.hash,\n                uri,\n                width: meta.width,\n                height: meta.height,\n            });\n            // TODO: FileSystem should probably support 'downloading' from drawable\n            // resources But for now it doesn't (it only supports raw resources) and\n            // React Native's Image works fine with drawable resource names for\n            // images.\n            if (Platform.OS === 'android' && !uri.includes(':') && (meta.width || meta.height)) {\n                asset.localUri = asset.uri;\n                asset.downloaded = true;\n            }\n            Asset.byHash[meta.hash] = asset;\n            return asset;\n        }\n        return Asset.fromMetadata(meta);\n    }\n    static fromMetadata(meta) {\n        // The hash of the whole asset, not to be confused with the hash of a specific file returned\n        // from `selectAssetSource`\n        const metaHash = meta.hash;\n        if (Asset.byHash[metaHash]) {\n            return Asset.byHash[metaHash];\n        }\n        else if (!IS_MANAGED_ENV && !Asset.byHash[metaHash]) {\n            throw new Error('Assets must be initialized with Asset.fromModule');\n        }\n        const { uri, hash } = AssetSources.selectAssetSource(meta);\n        const asset = new Asset({\n            name: meta.name,\n            type: meta.type,\n            hash,\n            uri,\n            width: meta.width,\n            height: meta.height,\n        });\n        Asset.byHash[metaHash] = asset;\n        return asset;\n    }\n    static fromURI(uri) {\n        if (Asset.byUri[uri]) {\n            return Asset.byUri[uri];\n        }\n        // Possibly a Base64-encoded URI\n        let type = '';\n        if (uri.indexOf(';base64') > -1) {\n            type = uri.split(';')[0].split('/')[1];\n        }\n        else {\n            const extension = AssetUris.getFileExtension(uri);\n            type = extension.startsWith('.') ? extension.substring(1) : extension;\n        }\n        const asset = new Asset({\n            name: '',\n            type,\n            hash: null,\n            uri,\n        });\n        Asset.byUri[uri] = asset;\n        return asset;\n    }\n    async _downloadAsyncWeb() {\n        if (ImageAssets.isImageType(this.type)) {\n            const { width, height, name } = await ImageAssets.getImageInfoAsync(this.uri);\n            this.width = width;\n            this.height = height;\n            this.name = name;\n        }\n        else {\n            this.name = AssetUris.getFilename(this.uri);\n        }\n        this.localUri = this.uri;\n    }\n    async _downloadAsyncManagedEnv() {\n        const cacheFileId = this.hash || computeMd5(this.uri);\n        const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`;\n        let { exists, md5 } = await FileSystem.getInfoAsync(localUri, {\n            md5: true,\n        });\n        if (!exists || (this.hash !== null && md5 !== this.hash)) {\n            ({ md5 } = await FileSystem.downloadAsync(this.uri, localUri, {\n                md5: true,\n            }));\n            if (this.hash !== null && md5 !== this.hash) {\n                throw new Error(`Downloaded file for asset '${this.name}.${this.type}' ` +\n                    `Located at ${this.uri} ` +\n                    `failed MD5 integrity check`);\n            }\n        }\n        this.localUri = localUri;\n    }\n    async _downloadAsyncUnmanagedEnv() {\n        // Bail out if it's already at a file URL because it's already available locally\n        if (this.uri.startsWith('file://')) {\n            this.localUri = this.uri;\n            return;\n        }\n        const cacheFileId = this.hash || computeMd5(this.uri);\n        const localUri = `${FileSystem.cacheDirectory}ExponentAsset-${cacheFileId}.${this.type}`;\n        // We don't check the FileSystem for an existing version of the asset and we\n        // also don't perform an integrity check!\n        await FileSystem.downloadAsync(this.uri, localUri);\n        this.localUri = localUri;\n    }\n    async downloadAsync() {\n        if (this.downloaded) {\n            return;\n        }\n        if (this.downloading) {\n            await new Promise((resolve, reject) => {\n                this._downloadCallbacks.push({ resolve, reject });\n            });\n            return;\n        }\n        this.downloading = true;\n        try {\n            if (Platform.OS === 'web') {\n                await this._downloadAsyncWeb();\n            }\n            else if (IS_MANAGED_ENV) {\n                await this._downloadAsyncManagedEnv();\n            }\n            else {\n                await this._downloadAsyncUnmanagedEnv();\n            }\n            this.downloaded = true;\n            this._downloadCallbacks.forEach(({ resolve }) => resolve());\n        }\n        catch (e) {\n            this._downloadCallbacks.forEach(({ reject }) => reject(e));\n            throw e;\n        }\n        finally {\n            this.downloading = false;\n            this._downloadCallbacks = [];\n        }\n    }\n};\nAsset.byHash = {};\nAsset.byUri = {};\n//# sourceMappingURL=Asset.js.map","if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('react-native/Libraries/Image/AssetRegistry');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\n//# sourceMappingURL=AssetRegistry.js.map","var __TEMP__ = require('react-native/Libraries/Image/resolveAssetSource');var resolveAssetSource = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = resolveAssetSource;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('react-native/Libraries/Image/resolveAssetSource');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\n//# sourceMappingURL=resolveAssetSource.js.map","var __TEMP__ = require('expo-constants');var Constants = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('@unimodules/core');var Platform = __TEMP__['Platform'];\nvar __TEMP__ = require('path-browserify');var path = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('react-native');var PixelRatio = __TEMP__['PixelRatio'];\nvar __TEMP__ = require('url-parse');var URL = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./AssetSourceResolver');var AssetSourceResolver = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./AssetUris');var getManifestBaseUrl = __TEMP__['getManifestBaseUrl'];\n// Fast lookup check if asset map has any overrides in the manifest\nconst assetMapOverride = Constants.manifest && Constants.manifest.assetMapOverride;\n// Compute manifest base URL if available\nconst manifestBaseUrl = Constants.experienceUrl\n    ? getManifestBaseUrl(Constants.experienceUrl)\n    : null;\n/**\n * Selects the best file for the given asset (ex: choosing the best scale for images) and returns\n * a { uri, hash } pair for the specific asset file.\n *\n * If the asset isn't an image with multiple scales, the first file is selected.\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.selectAssetSource = function selectAssetSource(meta) {\n    // Override with the asset map in manifest if available\n    if (assetMapOverride && assetMapOverride.hasOwnProperty(meta.hash)) {\n        meta = { ...meta, ...assetMapOverride[meta.hash] };\n    }\n    // This logic is based on that of AssetSourceResolver, with additional support for file hashes and\n    // explicitly provided URIs\n    const scale = AssetSourceResolver.pickScale(meta.scales, PixelRatio.get());\n    const index = meta.scales.findIndex(s => s === scale);\n    const hash = meta.fileHashes ? meta.fileHashes[index] || meta.fileHashes[0] : meta.hash;\n    // Allow asset processors to directly provide the URL to load\n    const uri = meta.fileUris ? meta.fileUris[index] || meta.fileUris[0] : meta.uri;\n    if (uri) {\n        return { uri: resolveUri(uri), hash };\n    }\n    // Check if the assetUrl was overridden in the manifest\n    const assetUrlOverride = Constants.manifest && Constants.manifest.assetUrlOverride;\n    if (assetUrlOverride) {\n        const uri = path.join(assetUrlOverride, hash);\n        return { uri: resolveUri(uri), hash };\n    }\n    const fileScale = scale === 1 ? '' : `@${scale}x`;\n    const fileExtension = meta.type ? `.${encodeURIComponent(meta.type)}` : '';\n    const suffix = `/${encodeURIComponent(meta.name)}${fileScale}${fileExtension}?platform=${encodeURIComponent(Platform.OS)}&hash=${encodeURIComponent(meta.hash)}`;\n    // For assets with a specified absolute URL, we use the existing origin instead of prepending the\n    // development server or production CDN URL origin\n    if (/^https?:\\/\\//.test(meta.httpServerLocation)) {\n        const uri = meta.httpServerLocation + suffix;\n        return { uri, hash };\n    }\n    // For assets during development, we use the development server's URL origin\n    if (Constants.manifest && Constants.manifest.developer) {\n        const baseUrl = new URL(Constants.manifest.bundleUrl);\n        baseUrl.set('pathname', meta.httpServerLocation + suffix);\n        return { uri: baseUrl.href, hash };\n    }\n    // Production CDN URIs are based on each asset file hash\n    return {\n        uri: `https://d1wp6m56sqw74a.cloudfront.net/~assets/${encodeURIComponent(hash)}`,\n        hash,\n    };\n};\n/**\n * Resolves the given URI to an absolute URI. If the given URI is already an absolute URI, it is\n * simply returned. Otherwise, if it is a relative URI, it is resolved relative to the manifest's\n * base URI.\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.resolveUri = function resolveUri(uri) {\n    if (!manifestBaseUrl) {\n        return uri;\n    }\n    const { protocol } = new URL(uri);\n    if (protocol !== '') {\n        return uri;\n    }\n    const baseUrl = new URL(manifestBaseUrl);\n    const resolvedPath = uri.startsWith('/') ? uri : path.join(baseUrl.pathname, uri);\n    baseUrl.set('pathname', resolvedPath);\n    return baseUrl.href;\n};\n//# sourceMappingURL=AssetSources.js.map","var __TEMP__ = require('react-native/Libraries/Image/AssetSourceResolver');var AssetSourceResolver = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = AssetSourceResolver;\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });var __TEMP__ = require('react-native/Libraries/Image/AssetSourceResolver');Object.keys(__TEMP__).forEach(function(k) { if (k === \"default\" || k === \"__esModule\") return; Object.defineProperty(exports, k, { enumerable: true, configurable: true, get: function() { return __TEMP__[k]; } }); });\n//# sourceMappingURL=AssetSourceResolver.js.map","var __TEMP__ = require('url-parse');var URL = __REQUIRE_DEFAULT__(__TEMP__);\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getFilename = function getFilename(url) {\n    const { pathname } = new URL(url, {});\n    return pathname.substring(pathname.lastIndexOf('/') + 1);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getFileExtension = function getFileExtension(url) {\n    const filename = getFilename(url);\n    const dotIndex = filename.lastIndexOf('.');\n    // Ignore leading dots for hidden files\n    return dotIndex > 0 ? filename.substring(dotIndex) : '';\n};\n/**\n * Returns the base URL from a manifest's URL. For example, given a manifest hosted at\n * https://example.com/app/manifest.json, the base URL would be https://example.com/app/. Query\n * parameters and fragments also are removed.\n *\n * For an Expo-hosted project with a manifest hosted at https://expo.io/@user/project/index.exp, the\n * base URL would be https://expo.io/@user/project.\n *\n * We also normalize the \"exp\" protocol to \"http\" to handle internal URLs with the Expo schemes used\n * to tell the OS to open the URLs in the the Expo client.\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getManifestBaseUrl = function getManifestBaseUrl(manifestUrl) {\n    const urlObject = new URL(manifestUrl, {});\n    // Change the scheme to http(s) if it is exp(s)\n    if (urlObject.protocol === 'exp:') {\n        urlObject.set('protocol', 'http:');\n    }\n    else if (urlObject.protocol === 'exps:') {\n        urlObject.set('protocol', 'https:');\n    }\n    // Trim filename, query parameters, and fragment, if any\n    const directory = urlObject.pathname.substring(0, urlObject.pathname.lastIndexOf('/') + 1);\n    urlObject.set('pathname', directory);\n    urlObject.set('query', '');\n    urlObject.set('hash', '');\n    return urlObject.href;\n};\n//# sourceMappingURL=AssetUris.js.map","var __TEMP__ = require('expo-constants');var Constants = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('expo-file-system');var FileSystem = __REQUIRE_WILDCARD__(__TEMP__);\n// Fast lookup check if assets are available in the local bundle\nconst bundledAssets = new Set(FileSystem.bundledAssets || []);\n/**\n * Returns the local URI of an embedded asset from its hash and type, or null if the asset is not\n * included in the app bundle.\n */\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getEmbeddedAssetUri = function getEmbeddedAssetUri(hash, type) {\n    const assetName = `asset_${hash}${type ? `.${type}` : ''}`;\n    if (__DEV__ || Constants.appOwnership !== 'standalone' || !bundledAssets.has(assetName)) {\n        return null;\n    }\n    return `${FileSystem.bundleDirectory}${assetName}`;\n};\n//# sourceMappingURL=EmbeddedAssets.js.map","var __TEMP__ = require('./AssetUris');var getFilename = __TEMP__['getFilename'];\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.isImageType = function isImageType(type) {\n    return /^(jpeg|jpg|gif|png|bmp|webp|heic)$/i.test(type);\n};\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });exports.getImageInfoAsync = function getImageInfoAsync(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onerror = reject;\n        img.onload = () => {\n            resolve({\n                name: getFilename(url),\n                width: img.naturalWidth,\n                height: img.naturalHeight,\n            });\n        };\n        img.src = url;\n    });\n};\n//# sourceMappingURL=ImageAssets.js.map"]}