{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxFlow = _interopRequireDefault(require(\"@babel/plugin-syntax-flow\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const FLOW_DIRECTIVE = /(@flow(\\s+(strict(-local)?|weak))?|@noflow)/;\n  let skipStrip = false;\n  const {\n    requireDirective = false,\n    allowDeclareFields = false\n  } = opts;\n  return {\n    name: \"transform-flow-strip-types\",\n    inherits: _pluginSyntaxFlow.default,\n    visitor: {\n      Program(path, {\n        file: {\n          ast: {\n            comments\n          }\n        }\n      }) {\n        skipStrip = false;\n        let directiveFound = false;\n\n        if (comments) {\n          for (const comment of comments) {\n            if (FLOW_DIRECTIVE.test(comment.value)) {\n              directiveFound = true;\n              comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n              if (!comment.value.replace(/\\*/g, \"\").trim()) {\n                comment.ignore = true;\n              }\n            }\n          }\n        }\n\n        if (!directiveFound && requireDirective) {\n          skipStrip = true;\n        }\n      },\n\n      ImportDeclaration(path) {\n        if (skipStrip) return;\n        if (!path.node.specifiers.length) return;\n        let typeCount = 0;\n        path.node.specifiers.forEach(({\n          importKind\n        }) => {\n          if (importKind === \"type\" || importKind === \"typeof\") {\n            typeCount++;\n          }\n        });\n\n        if (typeCount === path.node.specifiers.length) {\n          path.remove();\n        }\n      },\n\n      Flow(path) {\n        if (skipStrip) {\n          throw path.buildCodeFrameError(\"A @flow directive is required when using Flow annotations with \" + \"the `requireDirective` option.\");\n        }\n\n        path.remove();\n      },\n\n      ClassPrivateProperty(path) {\n        if (skipStrip) return;\n        path.node.typeAnnotation = null;\n      },\n\n      Class(path) {\n        if (skipStrip) return;\n        path.node.implements = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassProperty()) {\n            const {\n              node\n            } = child;\n\n            if (!allowDeclareFields && node.declare) {\n              throw child.buildCodeFrameError(`The 'declare' modifier is only allowed when the ` + `'allowDeclareFields' option of ` + `@babel/plugin-transform-flow-strip-types or ` + `@babel/preset-flow is enabled.`);\n            }\n\n            if (node.declare) {\n              child.remove();\n            } else if (!allowDeclareFields && !node.value && !node.decorators) {\n              child.remove();\n            } else {\n              node.variance = null;\n              node.typeAnnotation = null;\n            }\n          }\n        });\n      },\n\n      AssignmentPattern({\n        node\n      }) {\n        if (skipStrip) return;\n        node.left.optional = false;\n      },\n\n      Function({\n        node\n      }) {\n        if (skipStrip) return;\n\n        for (let i = 0; i < node.params.length; i++) {\n          const param = node.params[i];\n          param.optional = false;\n\n          if (param.type === \"AssignmentPattern\") {\n            param.left.optional = false;\n          }\n        }\n\n        node.predicate = null;\n      },\n\n      TypeCastExpression(path) {\n        if (skipStrip) return;\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTypeCastExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      CallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      OptionalCallExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      },\n\n      NewExpression({\n        node\n      }) {\n        if (skipStrip) return;\n        node.typeArguments = null;\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}