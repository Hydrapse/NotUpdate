{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _default(opts) {\n  const visitor = {};\n\n  visitor.JSXNamespacedName = function (path) {\n    if (opts.throwIfNamespace) {\n      throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n    }\n  };\n\n  visitor.JSXSpreadChild = function (path) {\n    throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n  };\n\n  visitor.JSXElement = {\n    exit(path, file) {\n      const callExpr = buildElementCall(path, file);\n\n      if (callExpr) {\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n    }\n\n  };\n  visitor.JSXFragment = {\n    exit(path, file) {\n      if (opts.compat) {\n        throw path.buildCodeFrameError(\"Fragment tags are only supported in React 16 and up.\");\n      }\n\n      const callExpr = buildFragmentCall(path, file);\n\n      if (callExpr) {\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n    }\n\n  };\n  return visitor;\n\n  function convertJSXIdentifier(node, parent) {\n    if (t.isJSXIdentifier(node)) {\n      if (node.name === \"this\" && t.isReferenced(node, parent)) {\n        return t.thisExpression();\n      } else if (t.isValidIdentifier(node.name, false)) {\n        node.type = \"Identifier\";\n      } else {\n        return t.stringLiteral(node.name);\n      }\n    } else if (t.isJSXMemberExpression(node)) {\n      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n    } else if (t.isJSXNamespacedName(node)) {\n      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n    }\n\n    return node;\n  }\n\n  function convertAttributeValue(node) {\n    if (t.isJSXExpressionContainer(node)) {\n      return node.expression;\n    } else {\n      return node;\n    }\n  }\n\n  function convertAttribute(node) {\n    const value = convertAttributeValue(node.value || t.booleanLiteral(true));\n\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {\n      var _value$extra;\n\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n      (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n    }\n\n    if (t.isJSXNamespacedName(node.name)) {\n      node.name = t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    } else if (t.isValidIdentifier(node.name.name, false)) {\n      node.name.type = \"Identifier\";\n    } else {\n      node.name = t.stringLiteral(node.name.name);\n    }\n\n    return t.inherits(t.objectProperty(node.name, value), node);\n  }\n\n  function buildElementCall(path, file) {\n    if (opts.filter && !opts.filter(path.node, file)) return;\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (opts.pre) {\n      opts.pre(state, file);\n    }\n\n    let attribs = openingPath.node.attributes;\n\n    if (attribs.length) {\n      attribs = buildOpeningElementAttributes(attribs, file);\n    } else {\n      attribs = t.nullLiteral();\n    }\n\n    args.push(attribs, ...path.node.children);\n\n    if (opts.post) {\n      opts.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(state.callee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function pushProps(_props, objs) {\n    if (!_props.length) return _props;\n    objs.push(t.objectExpression(_props));\n    return [];\n  }\n\n  function buildOpeningElementAttributes(attribs, file) {\n    let _props = [];\n    const objs = [];\n    const {\n      useSpread = false\n    } = file.opts;\n\n    if (typeof useSpread !== \"boolean\") {\n      throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n    }\n\n    const useBuiltIns = file.opts.useBuiltIns || false;\n\n    if (typeof useBuiltIns !== \"boolean\") {\n      throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n    }\n\n    if (useSpread && useBuiltIns) {\n      throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n    }\n\n    if (useSpread) {\n      const props = attribs.map(convertAttribute);\n      return t.objectExpression(props);\n    }\n\n    while (attribs.length) {\n      const prop = attribs.shift();\n\n      if (t.isJSXSpreadAttribute(prop)) {\n        _props = pushProps(_props, objs);\n        objs.push(prop.argument);\n      } else {\n        _props.push(convertAttribute(prop));\n      }\n    }\n\n    pushProps(_props, objs);\n\n    if (objs.length === 1) {\n      attribs = objs[0];\n    } else {\n      if (!t.isObjectExpression(objs[0])) {\n        objs.unshift(t.objectExpression([]));\n      }\n\n      const helper = useBuiltIns ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")) : file.addHelper(\"extends\");\n      attribs = t.callExpression(helper, objs);\n    }\n\n    return attribs;\n  }\n\n  function buildFragmentCall(path, file) {\n    if (opts.filter && !opts.filter(path.node, file)) return;\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (opts.pre) {\n      opts.pre(state, file);\n    }\n\n    args.push(t.nullLiteral(), ...path.node.children);\n\n    if (opts.post) {\n      opts.post(state, file);\n    }\n\n    file.set(\"usedFragment\", true);\n    const call = state.call || t.callExpression(state.callee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n}"]}