{"version":3,"sources":["index.js","enum.js","namespace.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxTypescript = _interopRequireDefault(require(\"@babel/plugin-syntax-typescript\"));\n\nvar _core = require(\"@babel/core\");\n\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\n\nvar _enum = _interopRequireDefault(require(\"./enum\"));\n\nvar _namespace = _interopRequireDefault(require(\"./namespace\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isInType(path) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSQualifiedName\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nconst PARSED_PARAMS = new WeakSet();\nconst GLOBAL_TYPES = new WeakMap();\n\nfunction isGlobalType(path, name) {\n  const program = path.find(path => path.isProgram()).node;\n  if (path.scope.hasOwnBinding(name)) return false;\n  if (GLOBAL_TYPES.get(program).has(name)) return true;\n  console.warn(`The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` + `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` + `never encountered it as a TypeScript type declaration.\\n` + `It will be treated as a JavaScript value.\\n\\n` + `This problem is likely caused by another plugin injecting\\n` + `\"${name}\" without registering it in the scope tracker. If you are the author\\n` + ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`);\n  return false;\n}\n\nfunction registerGlobalType(programScope, name) {\n  GLOBAL_TYPES.get(programScope.path.node).add(name);\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, {\n  jsxPragma = \"React\",\n  allowNamespaces = false,\n  allowDeclareFields = false,\n  onlyRemoveTypeImports = false\n}) => {\n  api.assertVersion(7);\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const classMemberVisitors = {\n    field(path) {\n      const {\n        node\n      } = path;\n\n      if (!allowDeclareFields && node.declare) {\n        throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);\n      }\n\n      if (node.definite || node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(`Definietly assigned fields and fields with the 'declare' modifier cannot` + ` be initialized here, but only in the constructor`);\n        }\n\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (!allowDeclareFields && !node.value && !node.decorators && !_core.types.isClassPrivateProperty(node)) {\n        path.remove();\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n    },\n\n    method({\n      node\n    }) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n    },\n\n    constructor(path, classPath) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      const parameterProperties = [];\n\n      for (const param of path.node.params) {\n        if (param.type === \"TSParameterProperty\" && !PARSED_PARAMS.has(param.parameter)) {\n          PARSED_PARAMS.add(param.parameter);\n          parameterProperties.push(param.parameter);\n        }\n      }\n\n      if (parameterProperties.length) {\n        const assigns = parameterProperties.map(p => {\n          let id;\n\n          if (_core.types.isIdentifier(p)) {\n            id = p;\n          } else if (_core.types.isAssignmentPattern(p) && _core.types.isIdentifier(p.left)) {\n            id = p.left;\n          } else {\n            throw path.buildCodeFrameError(\"Parameter properties can not be destructuring patterns.\");\n          }\n\n          return _core.template.statement.ast`this.${id} = ${id}`;\n        });\n        (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);\n      }\n    }\n\n  };\n  return {\n    name: \"transform-typescript\",\n    inherits: _pluginSyntaxTypescript.default,\n    visitor: {\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program(path, state) {\n        const {\n          file\n        } = state;\n        let fileJsxPragma = null;\n\n        if (!GLOBAL_TYPES.has(path.node)) {\n          GLOBAL_TYPES.set(path.node, new Set());\n        }\n\n        if (file.ast.comments) {\n          for (const comment of file.ast.comments) {\n            const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n            if (jsxMatches) {\n              fileJsxPragma = jsxMatches[1];\n            }\n          }\n        }\n\n        for (let stmt of path.get(\"body\")) {\n          if (_core.types.isImportDeclaration(stmt)) {\n            if (stmt.node.importKind === \"type\") {\n              stmt.remove();\n              continue;\n            }\n\n            if (!onlyRemoveTypeImports) {\n              if (stmt.node.specifiers.length === 0) {\n                continue;\n              }\n\n              let allElided = true;\n              const importsToRemove = [];\n\n              for (const specifier of stmt.node.specifiers) {\n                const binding = stmt.scope.getBinding(specifier.local.name);\n\n                if (binding && isImportTypeOnly({\n                  binding,\n                  programPath: path,\n                  jsxPragma: fileJsxPragma || jsxPragma\n                })) {\n                  importsToRemove.push(binding.path);\n                } else {\n                  allElided = false;\n                }\n              }\n\n              if (allElided) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n            }\n\n            continue;\n          }\n\n          if (stmt.isExportDeclaration()) {\n            stmt = stmt.get(\"declaration\");\n          }\n\n          if (stmt.isVariableDeclaration({\n            declare: true\n          })) {\n            for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n              registerGlobalType(path.scope, name);\n            }\n          } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({\n            declare: true\n          }) || stmt.isTSEnumDeclaration({\n            declare: true\n          }) || stmt.isTSModuleDeclaration({\n            declare: true\n          }) && stmt.get(\"id\").isIdentifier()) {\n            registerGlobalType(path.scope, stmt.node.id.name);\n          }\n        }\n      },\n\n      ExportNamedDeclaration(path) {\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(({\n          local\n        }) => isGlobalType(path, local.name))) {\n          path.remove();\n        }\n      },\n\n      ExportSpecifier(path) {\n        if (!path.parent.source && isGlobalType(path, path.node.local.name)) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path) {\n        if (_core.types.isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {\n          path.remove();\n        }\n      },\n\n      TSDeclareFunction(path) {\n        path.remove();\n      },\n\n      TSDeclareMethod(path) {\n        path.remove();\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          path.remove();\n        }\n      },\n\n      VariableDeclarator({\n        node\n      }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const {\n          node\n        } = path;\n\n        if (node.declare) {\n          path.remove();\n          return;\n        }\n      },\n\n      Class(path) {\n        const {\n          node\n        } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(child, path);\n            } else {\n              classMemberVisitors.method(child, path);\n            }\n          } else if (child.isClassProperty() || child.isClassPrivateProperty()) {\n            classMemberVisitors.field(child, path);\n          }\n        });\n      },\n\n      Function({\n        node\n      }) {\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n        const p0 = node.params[0];\n\n        if (p0 && _core.types.isIdentifier(p0) && p0.name === \"this\") {\n          node.params.shift();\n        }\n\n        node.params = node.params.map(p => {\n          return p.type === \"TSParameterProperty\" ? p.parameter : p;\n        });\n      },\n\n      TSModuleDeclaration(path) {\n        (0, _namespace.default)(path, _core.types, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        (0, _enum.default)(path, _core.types);\n      },\n\n      TSImportEqualsDeclaration(path) {\n        throw path.buildCodeFrameError(\"`import =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using \" + \"`import <moduleName> from '<moduleName>';` alongside \" + \"Typescript's --allowSyntheticDefaultImports option.\");\n      },\n\n      TSExportAssignment(path) {\n        throw path.buildCodeFrameError(\"`export =` is not supported by @babel/plugin-transform-typescript\\n\" + \"Please consider using `export <value>;`.\");\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      TSAsExpression(path) {\n        let {\n          node\n        } = path;\n\n        do {\n          node = node.expression;\n        } while (_core.types.isTSAsExpression(node));\n\n        path.replaceWith(node);\n      },\n\n      TSNonNullExpression(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      }\n\n    }\n  };\n\n  function visitPattern({\n    node\n  }) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (_core.types.isIdentifier(node) && node.optional) node.optional = null;\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    jsxPragma\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (binding.identifier.name !== jsxPragma) {\n      return true;\n    }\n\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      JSXElement() {\n        sourceFileHasJsx = true;\n      },\n\n      JSXFragment() {\n        sourceFileHasJsx = true;\n      }\n\n    });\n    return !sourceFileHasJsx;\n  }\n});\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction transpileEnum(path, t) {\n  const {\n    node\n  } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  if (node.const) {\n    throw path.buildCodeFrameError(\"'const' enums are not supported.\");\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        path.insertAfter(fill);\n\n        if (seen(path.parentPath)) {\n          path.remove();\n        } else {\n          const isGlobal = t.isProgram(path.parent);\n          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0]);\n        }\n\n        break;\n      }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id, t, kind) {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = (0, _core.template)(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\nfunction enumFill(path, t, id) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) => buildEnumMember(t.isStringLiteral(memberValue), {\n    ENUM: t.cloneNode(id),\n    NAME: memberName,\n    VALUE: memberValue\n  }));\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments\n  });\n}\n\nfunction translateEnumValues(path, t) {\n  const seen = Object.create(null);\n  let prev = -1;\n  return path.node.members.map(member => {\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value;\n\n    if (initializer) {\n      const constValue = evaluate(initializer, seen);\n\n      if (constValue !== undefined) {\n        seen[name] = constValue;\n\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n          prev = constValue;\n        } else {\n          (0, _assert.default)(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n          prev = undefined;\n        }\n      } else {\n        value = initializer;\n        prev = undefined;\n      }\n    } else {\n      if (prev !== undefined) {\n        prev++;\n        value = t.numericLiteral(prev);\n        seen[name] = prev;\n      } else {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      }\n    }\n\n    return [name, value];\n  });\n}\n\nfunction evaluate(expr, seen) {\n  return evalConstant(expr);\n\n  function evalConstant(expr) {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n\n      case \"NumericLiteral\":\n        return expr.value;\n\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n\n      case \"Identifier\":\n        return seen[expr.name];\n\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator\n  }) {\n    const value = evalConstant(argument);\n\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n\n      case \"-\":\n        return -value;\n\n      case \"~\":\n        return ~value;\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr) {\n    const left = evalConstant(expr.left);\n\n    if (left === undefined) {\n      return undefined;\n    }\n\n    const right = evalConstant(expr.right);\n\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n\n      case \"<<\":\n        return left << right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"*\":\n        return left * right;\n\n      case \"/\":\n        return left / right;\n\n      case \"+\":\n        return left + right;\n\n      case \"-\":\n        return left - right;\n\n      case \"%\":\n        return left % right;\n\n      default:\n        return undefined;\n    }\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileNamespace;\n\nvar _core = require(\"@babel/core\");\n\nfunction transpileNamespace(path, t, allowNamespaces) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path.hub.file.buildCodeFrameError(path.node.id, \"Namespace not marked type-only declare.\" + \" Non-declarative namespaces are only supported experimentally in Babel.\" + \" To enable and review caveats see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n\n  const name = path.node.id.name;\n  const value = handleNested(path, t, t.cloneDeep(path.node));\n  const bound = path.scope.hasOwnBinding(name);\n\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(t, name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);\n  }\n}\n\nfunction getDeclaration(t, name) {\n  return t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(name))]);\n}\n\nfunction getMemberExpression(t, name, itemName) {\n  return t.memberExpression(t.identifier(name), t.identifier(itemName));\n}\n\nfunction handleNested(path, t, node, parentExport) {\n  const names = new Set();\n  const realName = node.id;\n  const name = path.scope.generateUid(realName.name);\n  const namespaceTopLevel = node.body.body;\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\":\n        {\n          const transformed = handleNested(path, t, subNode);\n          const moduleName = subNode.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);\n          }\n\n          continue;\n        }\n\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n\n      case \"VariableDeclaration\":\n        for (const variable of subNode.declarations) {\n          names.add(variable.id.name);\n        }\n\n        continue;\n\n      default:\n        continue;\n\n      case \"ExportNamedDeclaration\":\n    }\n\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        {\n          const itemName = subNode.declaration.id.name;\n          names.add(itemName);\n          namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression(\"=\", getMemberExpression(t, name, itemName), t.identifier(itemName))));\n          break;\n        }\n\n      case \"VariableDeclaration\":\n        if (subNode.declaration.kind !== \"const\") {\n          throw path.hub.file.buildCodeFrameError(subNode.declaration, \"Namespaces exporting non-const are not supported by Babel.\" + \" Change to const or see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n        }\n\n        for (const variable of subNode.declaration.declarations) {\n          variable.init = t.assignmentExpression(\"=\", getMemberExpression(t, name, variable.id.name), variable.init);\n        }\n\n        namespaceTopLevel[i] = subNode.declaration;\n        break;\n\n      case \"TSModuleDeclaration\":\n        {\n          const transformed = handleNested(path, t, subNode.declaration, t.identifier(name));\n          const moduleName = subNode.declaration.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);\n          }\n        }\n    }\n  }\n\n  let fallthroughValue = t.objectExpression([]);\n\n  if (parentExport) {\n    fallthroughValue = _core.template.expression.ast`\n      ${parentExport}.${realName} || (\n        ${parentExport}.${realName} = ${fallthroughValue}\n      )\n    `;\n  }\n\n  return _core.template.statement.ast`\n    (function (${t.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${realName} = ${fallthroughValue}));\n  `;\n}"]}