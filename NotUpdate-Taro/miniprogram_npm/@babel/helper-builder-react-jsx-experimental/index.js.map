{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.helper = helper;\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = _interopRequireDefault(require(\"@babel/helper-annotate-as-pure\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\n\nfunction helper(babel, options) {\n  const FILE_NAME_VAR = \"_jsxFileName\";\n  const JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\n  const JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\n  const JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\n  const JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n  const IMPORT_NAME_SIZE = options.development ? 3 : 4;\n  const {\n    importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n    runtime: RUNTIME_DEFAULT = DEFAULT.runtime,\n    pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n    pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n  } = options;\n  const injectMetaPropertiesVisitor = {\n    JSXOpeningElement(path, state) {\n      for (const attr of path.get(\"attributes\")) {\n        if (!attr.isJSXElement()) continue;\n        const {\n          name\n        } = attr.node.name;\n\n        if (name === \"__source\" || name === \"__self\") {\n          throw path.buildCodeFrameError(`__source and __self should not be defined in props and are reserved for internal usage.`);\n        }\n      }\n\n      const source = t.jsxAttribute(t.jsxIdentifier(\"__source\"), t.jsxExpressionContainer(makeSource(path, state)));\n      const self = t.jsxAttribute(t.jsxIdentifier(\"__self\"), t.jsxExpressionContainer(t.thisExpression()));\n      path.pushContainer(\"attributes\", [source, self]);\n    }\n\n  };\n  return {\n    JSXNamespacedName(path, state) {\n      const throwIfNamespace = state.opts.throwIfNamespace === undefined ? true : !!state.opts.throwIfNamespace;\n\n      if (throwIfNamespace) {\n        throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n      }\n    },\n\n    JSXSpreadChild(path) {\n      throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n    },\n\n    JSXElement: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n          callExpr = buildCreateElementCall(path, file);\n        } else {\n          callExpr = buildJSXElementCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n    JSXFragment: {\n      exit(path, file) {\n        let callExpr;\n\n        if (file.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\") {\n          callExpr = buildCreateElementFragmentCall(path, file);\n        } else {\n          callExpr = buildJSXFragmentCall(path, file);\n        }\n\n        path.replaceWith(t.inherits(callExpr, path.node));\n      }\n\n    },\n\n    JSXAttribute(path) {\n      if (t.isJSXElement(path.node.value)) {\n        path.node.value = t.jsxExpressionContainer(path.node.value);\n      }\n    },\n\n    Program: {\n      enter(path, state) {\n        if (hasJSX(path)) {\n          const {\n            file\n          } = state;\n          let runtime = RUNTIME_DEFAULT;\n          let source = IMPORT_SOURCE_DEFAULT;\n          let sourceSet = !!options.importSource;\n          let pragma = PRAGMA_DEFAULT;\n          let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n          let pragmaSet = !!options.pragma;\n          let pragmaFragSet = !!options.pragmaFrag;\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n              if (sourceMatches) {\n                source = sourceMatches[1];\n                sourceSet = true;\n              }\n\n              const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n              if (runtimeMatches) {\n                runtime = runtimeMatches[1];\n              }\n\n              const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxMatches) {\n                pragma = jsxMatches[1];\n                pragmaSet = true;\n              }\n\n              const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n              if (jsxFragMatches) {\n                pragmaFrag = jsxFragMatches[1];\n                pragmaFragSet = true;\n              }\n            }\n          }\n\n          state.set(\"@babel/plugin-react-jsx/runtime\", runtime);\n\n          if (runtime === \"classic\") {\n            if (sourceSet) {\n              throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n            }\n\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(pragma));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(pragmaFrag));\n            state.set(\"@babel/plugin-react-jsx/usedFragment\", false);\n            state.set(\"@babel/plugin-react-jsx/pragmaSet\", pragma !== DEFAULT.pragma);\n            state.set(\"@babel/plugin-react-jsx/pragmaFragSet\", pragmaFrag !== DEFAULT.pragmaFrag);\n          } else if (runtime === \"automatic\") {\n            if (pragmaSet || pragmaFragSet) {\n              throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n            }\n\n            const importName = addAutoImports(path, Object.assign({}, state.opts, {\n              source\n            }));\n            state.set(\"@babel/plugin-react-jsx/jsxIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsx\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxStaticIdentifier\", createIdentifierParser(createIdentifierName(path, options.development ? \"jsxDEV\" : \"jsxs\", importName)));\n            state.set(\"@babel/plugin-react-jsx/createElementIdentifier\", createIdentifierParser(createIdentifierName(path, \"createElement\", importName)));\n            state.set(\"@babel/plugin-react-jsx/jsxFragIdentifier\", createIdentifierParser(createIdentifierName(path, \"Fragment\", importName)));\n            state.set(\"@babel/plugin-react-jsx/importSourceSet\", source !== DEFAULT.importSource);\n          } else {\n            throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n          }\n\n          if (options.development) {\n            path.traverse(injectMetaPropertiesVisitor, state);\n          }\n        }\n      },\n\n      exit(path, state) {\n        if (state.get(\"@babel/plugin-react-jsx/runtime\") === \"classic\" && state.get(\"@babel/plugin-react-jsx/pragmaSet\") && state.get(\"@babel/plugin-react-jsx/usedFragment\") && !state.get(\"@babel/plugin-react-jsx/pragmaFragSet\")) {\n          throw new Error(\"transform-react-jsx: pragma has been set but \" + \"pragmaFrag has not been set\");\n        }\n      }\n\n    }\n  };\n\n  function shouldUseCreateElement(path) {\n    const openingPath = path.get(\"openingElement\");\n    const attributes = openingPath.node.attributes;\n    let seenPropsSpread = false;\n\n    for (let i = 0; i < attributes.length; i++) {\n      const attr = attributes[i];\n\n      if (seenPropsSpread && t.isJSXAttribute(attr) && attr.name.name === \"key\") {\n        return true;\n      } else if (t.isJSXSpreadAttribute(attr)) {\n        seenPropsSpread = true;\n      }\n    }\n\n    return false;\n  }\n\n  function createIdentifierName(path, name, importName) {\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const identifierName = `${importName[name]}`;\n      return identifierName;\n    } else {\n      return `${importName[name]}.${name}`;\n    }\n  }\n\n  function getImportNames(parentPath) {\n    const imports = new Set();\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        if (path.type === \"JSXFragment\") imports.add(\"Fragment\");\n        const openingPath = path.get(\"openingElement\");\n        const validChildren = t.react.buildChildren(openingPath.parent);\n        let importName;\n\n        if (path.type === \"JSXElement\" && shouldUseCreateElement(path)) {\n          importName = \"createElement\";\n        } else if (options.development) {\n          importName = \"jsxDEV\";\n        } else if (validChildren.length > 1) {\n          importName = \"jsxs\";\n        } else {\n          importName = \"jsx\";\n        }\n\n        imports.add(importName);\n\n        if (imports.size === IMPORT_NAME_SIZE) {\n          path.stop();\n        }\n      }\n\n    });\n    return imports;\n  }\n\n  function hasJSX(parentPath) {\n    let fileHasJSX = false;\n    parentPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        fileHasJSX = true;\n        path.stop();\n      }\n\n    });\n    return fileHasJSX;\n  }\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${options.development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function addAutoImports(path, state) {\n    const imports = getImportNames(path, state);\n\n    if ((0, _helperModuleImports.isModule)(path)) {\n      const importMap = {};\n      imports.forEach(importName => {\n        if (!importMap[importName]) {\n          importMap[importName] = (0, _helperModuleImports.addNamed)(path, importName, getSource(state.source, importName), {\n            importedInterop: \"uncompiled\",\n            ensureLiveReference: true\n          }).name;\n        }\n      });\n      return importMap;\n    } else {\n      const importMap = {};\n      const sourceMap = {};\n      imports.forEach(importName => {\n        const source = getSource(state.source, importName);\n\n        if (!importMap[importName]) {\n          if (!sourceMap[source]) {\n            sourceMap[source] = (0, _helperModuleImports.addNamespace)(path, source, {\n              importedInterop: \"uncompiled\",\n              ensureLiveReference: true\n            }).name;\n          }\n\n          importMap[importName] = sourceMap[source];\n        }\n      });\n      return importMap;\n    }\n  }\n\n  function createIdentifierParser(id) {\n    return () => {\n      return id.split(\".\").map(name => t.identifier(name)).reduce((object, property) => t.memberExpression(object, property));\n    };\n  }\n\n  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n    const fileLineLiteral = lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n    const fileColumnLiteral = column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n    const fileNameProperty = t.objectProperty(t.identifier(\"fileName\"), fileNameIdentifier);\n    const lineNumberProperty = t.objectProperty(t.identifier(\"lineNumber\"), fileLineLiteral);\n    const columnNumberProperty = t.objectProperty(t.identifier(\"columnNumber\"), fileColumnLiteral);\n    return t.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n  }\n\n  function makeSource(path, state) {\n    const location = path.node.loc;\n\n    if (!location) {\n      return;\n    }\n\n    if (!state.fileNameIdentifier) {\n      const {\n        filename = \"\"\n      } = state;\n      const fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);\n      const scope = path.hub.getScope();\n\n      if (scope) {\n        scope.push({\n          id: fileNameIdentifier,\n          init: t.stringLiteral(filename)\n        });\n      }\n\n      state.fileNameIdentifier = fileNameIdentifier;\n    }\n\n    return makeTrace(state.fileNameIdentifier, location.start.line, location.start.column);\n  }\n\n  function convertJSXIdentifier(node, parent) {\n    if (t.isJSXIdentifier(node)) {\n      if (node.name === \"this\" && t.isReferenced(node, parent)) {\n        return t.thisExpression();\n      } else if (t.isValidIdentifier(node.name, false)) {\n        node.type = \"Identifier\";\n      } else {\n        return t.stringLiteral(node.name);\n      }\n    } else if (t.isJSXMemberExpression(node)) {\n      return t.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n    } else if (t.isJSXNamespacedName(node)) {\n      return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n    }\n\n    return node;\n  }\n\n  function convertAttributeValue(node) {\n    if (t.isJSXExpressionContainer(node)) {\n      return node.expression;\n    } else {\n      return node;\n    }\n  }\n\n  function convertAttribute(node) {\n    const value = convertAttributeValue(node.value || t.booleanLiteral(true));\n\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    if (t.isStringLiteral(value) && !t.isJSXExpressionContainer(node.value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    if (t.isJSXNamespacedName(node.name)) {\n      node.name = t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    } else if (t.isValidIdentifier(node.name.name, false)) {\n      node.name.type = \"Identifier\";\n    } else {\n      node.name = t.stringLiteral(node.name.name);\n    }\n\n    return t.inherits(t.objectProperty(node.name, value), node);\n  }\n\n  function buildJSXElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let attribs = [];\n    const extracted = Object.create(null);\n\n    for (const attr of openingPath.get(\"attributes\")) {\n      if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n        const {\n          name\n        } = attr.node.name;\n\n        switch (name) {\n          case \"__source\":\n          case \"__self\":\n            if (extracted[name]) throw sourceSelfError(path, name);\n\n          case \"key\":\n            extracted[name] = convertAttributeValue(attr.node.value);\n            break;\n\n          default:\n            attribs.push(attr.node);\n        }\n      } else {\n        attribs.push(attr.node);\n      }\n    }\n\n    if (attribs.length || path.node.children.length) {\n      attribs = buildJSXOpeningElementAttributes(attribs, file, path.node.children);\n    } else {\n      attribs = t.objectExpression([]);\n    }\n\n    args.push(attribs);\n\n    if (!options.development) {\n      if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n    } else {\n      var _extracted$key, _extracted$__source, _extracted$__self;\n\n      args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : t.thisExpression());\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildJSXOpeningElementAttributes(attribs, file, children) {\n    const props = attribs.map(convertAttribute);\n\n    if (children && children.length > 0) {\n      if (children.length === 1) {\n        props.push(t.objectProperty(t.identifier(\"children\"), children[0]));\n      } else {\n        props.push(t.objectProperty(t.identifier(\"children\"), t.arrayExpression(children)));\n      }\n    }\n\n    return t.objectExpression(props);\n  }\n\n  function buildJSXFragmentCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    let childrenNode;\n\n    if (path.node.children.length > 0) {\n      if (path.node.children.length === 1) {\n        childrenNode = path.node.children[0];\n      } else {\n        childrenNode = t.arrayExpression(path.node.children);\n      }\n    }\n\n    args.push(t.objectExpression(childrenNode !== undefined ? [t.objectProperty(t.identifier(\"children\"), childrenNode)] : []));\n\n    if (options.development) {\n      args.push(path.scope.buildUndefinedNode(), t.booleanLiteral(path.node.children.length > 1));\n    }\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(path.node.children.length > 1 ? state.jsxStaticCallee : state.jsxCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementFragmentCall(path, file) {\n    if (options.filter && !options.filter(path.node, file)) {\n      return;\n    }\n\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const args = [];\n    const tagName = null;\n    const tagExpr = file.get(\"@babel/plugin-react-jsx/jsxFragIdentifier\")();\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    args.push(t.nullLiteral(), ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    file.set(\"@babel/plugin-react-jsx/usedFragment\", true);\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementCall(path, file) {\n    const openingPath = path.get(\"openingElement\");\n    openingPath.parent.children = t.react.buildChildren(openingPath.parent);\n    const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n    const args = [];\n    let tagName;\n\n    if (t.isIdentifier(tagExpr)) {\n      tagName = tagExpr.name;\n    } else if (t.isLiteral(tagExpr)) {\n      tagName = tagExpr.value;\n    }\n\n    const state = {\n      tagExpr: tagExpr,\n      tagName: tagName,\n      args: args,\n      pure: false\n    };\n\n    if (options.pre) {\n      options.pre(state, file);\n    }\n\n    const attribs = buildCreateElementOpeningElementAttributes(path, openingPath.node.attributes);\n    args.push(attribs, ...path.node.children);\n\n    if (options.post) {\n      options.post(state, file);\n    }\n\n    const call = state.call || t.callExpression(state.createElementCallee, args);\n    if (state.pure) (0, _helperAnnotateAsPure.default)(call);\n    return call;\n  }\n\n  function buildCreateElementOpeningElementAttributes(path, attribs) {\n    const props = [];\n    const found = Object.create(null);\n\n    for (const attr of attribs) {\n      const name = t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name) && attr.name.name;\n\n      if (name === \"__source\" || name === \"__self\") {\n        if (found[name]) throw sourceSelfError(path, name);\n        found[name] = true;\n        if (!options.development) continue;\n      }\n\n      props.push(convertAttribute(attr));\n    }\n\n    return props.length > 0 ? t.objectExpression(props) : t.nullLiteral();\n  }\n\n  function sourceSelfError(path, name) {\n    const pluginName = `transform-react-jsx-${name.slice(2)}`;\n    return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n  }\n}"]}